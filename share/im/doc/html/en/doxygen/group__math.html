<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: Math Utilities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Math Utilities<br/>
<small>
[<a class="el" href="group__util.html">Utilities</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Math Utilities:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__math.png" border="0" alt="" usemap="#group____math"/>
<map name="group____math" id="group____math">
<area shape="rect" id="node2" href="group__util.html" title="Utilities" alt="" coords="7,5,79,37"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#gab6e485874c1236f082d5c9f1457a169f">imRound</a> (float x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__math.html#ga6bd8128d9ee42b8b7caedcf426ba2d29">imResampleInt</a> (int x, float factor)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class TU &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gaae4d4eb606d7b5754fcb807bece3b2ab">imZeroOrderDecimation</a> (int width, int height, T *map, float xl, float yl, float box_width, float box_height, TU Dummy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class TU &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gad1ba95ea2bdfabed568cac9305d8b2fc">imBilinearDecimation</a> (int width, int height, T *map, float xl, float yl, float box_width, float box_height, TU Dummy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga67bdb52e36ad92d3cd496c777b7d5532">imZeroOrderInterpolation</a> (int width, int height, T *map, float xl, float yl)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga6dcf664b64addd6c306fc54070e08b78">imBilinearInterpolation</a> (int width, int height, T *map, float xl, float yl)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T , class TU &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga14ba162a25fd3eb7c6412ce76d91ee92">imBicubicInterpolation</a> (int width, int height, T *map, float xl, float yl, TU Dummy)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#ga9bd89a4d9aa37c684d287ba542e6cbaa">imMinMax</a> (const T *map, int count, T &amp;min, T &amp;max, int abssolute=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__math.html#gadcba55e31749ec46e337fe73592b5182">imMinMaxType</a> (const T *map, int count, T &amp;min, T &amp;max, int abssolute=0)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b></b></dt><dd>When converting between continuous and discrete use: <br/>
 Continuous = Discrete + 0.5 [Reconstruction/Interpolation] <br/>
 Discrete = Round(Continuous - 0.5) [Sampling/Quantization] <br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Notice that must check min-max limits when converting from Continuous to Discrete. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When converting between discrete and discrete use: <br/>
 integer src_size, dst_len, src_i, dst_i <br/>
 real factor = (real)(dst_size)/(real)(src_size) <br/>
 dst_i = Round(factor*(src_i + 0.5) - 0.5) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See <a class="el" href="im__math_8h.html">im_math.h</a> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gab6e485874c1236f082d5c9f1457a169f"></a><!-- doxytag: member="im_math.h::imRound" ref="gab6e485874c1236f082d5c9f1457a169f" args="(float x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imRound </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Round a real to the nearest integer. </p>

<p>Referenced by <a class="el" href="group__color.html#ga27635c8fbb832f40533894efe7873cab">imColorQuantize()</a>, and <a class="el" href="group__math.html#ga67bdb52e36ad92d3cd496c777b7d5532">imZeroOrderInterpolation()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(x &lt; 0? x-0.5f: x+0.5f);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6bd8128d9ee42b8b7caedcf426ba2d29"></a><!-- doxytag: member="im_math.h::imResampleInt" ref="ga6bd8128d9ee42b8b7caedcf426ba2d29" args="(int x, float factor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imResampleInt </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>factor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts between two discrete grids. factor is "dst_size/src_size". </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> xr = factor*(x + 0.5f) - 0.5f;
  <span class="keywordflow">return</span> (<span class="keywordtype">int</span>)(xr &lt; 0? xr-0.5f: xr+0.5f);  <span class="comment">/* Round */</span>
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaae4d4eb606d7b5754fcb807bece3b2ab"></a><!-- doxytag: member="im_math.h::imZeroOrderDecimation" ref="gaae4d4eb606d7b5754fcb807bece3b2ab" args="(int width, int height, T *map, float xl, float yl, float box_width, float box_height, TU Dummy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T imZeroOrderDecimation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>box_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>box_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TU&nbsp;</td>
          <td class="paramname"> <em>Dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does Zero Order Decimation (Mean). </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> x0,x1,y0,y1;
  (void)Dummy;

  x0 = (int)floor(xl - box_width/2.0 - 0.5) + 1;
  y0 = (int)floor(yl - box_height/2.0 - 0.5) + 1;
  x1 = (int)floor(xl + box_width/2.0 - 0.5);
  y1 = (int)floor(yl + box_height/2.0 - 0.5);

  <span class="keywordflow">if</span> (x0 == x1) x1++;
  <span class="keywordflow">if</span> (y0 == y1) y1++;

  x0 = x0&lt;0? 0: x0&gt;width-1? width-1: x0;
  y0 = y0&lt;0? 0: y0&gt;height-1? height-1: y0;
  x1 = x1&lt;0? 0: x1&gt;width-1? width-1: x1;
  y1 = y1&lt;0? 0: y1&gt;height-1? height-1: y1;

  TU Value;
  <span class="keywordtype">int</span> Count = 0;

  Value = 0;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = y0; y &lt;= y1; y++)
  {
    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = x0; x &lt;= x1; x++)
    {
      Value += map[y*width+x];
      Count++;
    }
  }

  <span class="keywordflow">if</span> (Count == 0)
  {
    Value = 0;
    <span class="keywordflow">return</span> (T)Value;
  }

  <span class="keywordflow">return</span> (T)(Value/(float)Count);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gad1ba95ea2bdfabed568cac9305d8b2fc"></a><!-- doxytag: member="im_math.h::imBilinearDecimation" ref="gad1ba95ea2bdfabed568cac9305d8b2fc" args="(int width, int height, T *map, float xl, float yl, float box_width, float box_height, TU Dummy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T imBilinearDecimation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>box_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>box_height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TU&nbsp;</td>
          <td class="paramname"> <em>Dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does Bilinear Decimation. </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> x0,x1,y0,y1;
  (void)Dummy;

  x0 = (int)floor(xl - box_width/2.0 - 0.5) + 1;
  y0 = (int)floor(yl - box_height/2.0 - 0.5) + 1;
  x1 = (int)floor(xl + box_width/2.0 - 0.5);
  y1 = (int)floor(yl + box_height/2.0 - 0.5);

  <span class="keywordflow">if</span> (x0 == x1) x1++;
  <span class="keywordflow">if</span> (y0 == y1) y1++;

  x0 = x0&lt;0? 0: x0&gt;width-1? width-1: x0;
  y0 = y0&lt;0? 0: y0&gt;height-1? height-1: y0;
  x1 = x1&lt;0? 0: x1&gt;width-1? width-1: x1;
  y1 = y1&lt;0? 0: y1&gt;height-1? height-1: y1;

  TU Value, LineValue;
  <span class="keywordtype">float</span> LineNorm, Norm, dxr, dyr;

  Value = 0;
  Norm = 0;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = y0; y &lt;= y1; y++)
  {
    dyr = yl - (y+0.5f);
    <span class="keywordflow">if</span> (dyr &lt; 0) dyr *= -1;

    LineValue = 0;
    LineNorm = 0;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = x0; x &lt;= x1; x++)
    {
      dxr = xl - (x+0.5f);
      <span class="keywordflow">if</span> (dxr &lt; 0) dxr *= -1;

      LineValue += map[y*width+x] * dxr;
      LineNorm += dxr;
    }

    Value += LineValue * dyr;
    Norm += dyr * LineNorm;
  }

  <span class="keywordflow">if</span> (Norm == 0)
  {
    Value = 0;
    <span class="keywordflow">return</span> (T)Value;
  }

  <span class="keywordflow">return</span> (T)(Value/Norm);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga67bdb52e36ad92d3cd496c777b7d5532"></a><!-- doxytag: member="im_math.h::imZeroOrderInterpolation" ref="ga67bdb52e36ad92d3cd496c777b7d5532" args="(int width, int height, T *map, float xl, float yl)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T imZeroOrderInterpolation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does Zero Order Interpolation (Nearest Neighborhood). </p>

<p>References <a class="el" href="group__math.html#gab6e485874c1236f082d5c9f1457a169f">imRound()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> x0 = <a class="code" href="group__math.html#gab6e485874c1236f082d5c9f1457a169f">imRound</a>(xl-0.5f);
  <span class="keywordtype">int</span> y0 = <a class="code" href="group__math.html#gab6e485874c1236f082d5c9f1457a169f">imRound</a>(yl-0.5f);
  x0 = x0&lt;0? 0: x0&gt;width-1? width-1: x0;
  y0 = y0&lt;0? 0: y0&gt;height-1? height-1: y0;
  <span class="keywordflow">return</span> map[y0*width + x0];
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6dcf664b64addd6c306fc54070e08b78"></a><!-- doxytag: member="im_math.h::imBilinearInterpolation" ref="ga6dcf664b64addd6c306fc54070e08b78" args="(int width, int height, T *map, float xl, float yl)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T imBilinearInterpolation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yl</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does Bilinear Interpolation. </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> x0, y0, x1, y1;
  <span class="keywordtype">float</span> t, u;

  <span class="keywordflow">if</span> (xl &lt; 0.5)
  {
    x1 = x0 = 0; 
    t = 0;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (xl &gt;= width-0.5)
  {
    x1 = x0 = width-1;
    t = 0;
  }
  <span class="keywordflow">else</span>
  {
    x0 = (int)(xl-0.5f);
    x1 = x0+1;
    t = xl - (x0+0.5f);
  }

  <span class="keywordflow">if</span> (yl &lt; 0.5)
  {
    y1 = y0 = 0; 
    u = 0;
  }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (yl &gt;= height-0.5)
  {
    y1 = y0 = height-1;
    u = 0;
  }
  <span class="keywordflow">else</span>
  {
    y0 = (int)(yl-0.5f);
    y1 = y0+1;
    u = yl - (y0+0.5f);
  }

  T fll = map[y0*width + x0];
  T fhl = map[y0*width + x1];
  T flh = map[y1*width + x0];
  T fhh = map[y1*width + x1];

  <span class="keywordflow">return</span> (T)((fhh - flh - fhl + fll) * u * t +
                         (fhl - fll) * t +
                         (flh - fll) * u +
                                fll);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga14ba162a25fd3eb7c6412ce76d91ee92"></a><!-- doxytag: member="im_math.h::imBicubicInterpolation" ref="ga14ba162a25fd3eb7c6412ce76d91ee92" args="(int width, int height, T *map, float xl, float yl, TU Dummy)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class TU &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T imBicubicInterpolation </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>yl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TU&nbsp;</td>
          <td class="paramname"> <em>Dummy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Does Bicubic Interpolation. </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> X[4], Y[4];
  <span class="keywordtype">float</span> t, u;
  (void)Dummy;

  <span class="keywordflow">if</span> (xl &gt;= width-0.5)
  {
    X[3] = X[2] = X[1] = width-1;
    X[0] = X[1]-1;
    t = 0;
  }
  <span class="keywordflow">else</span>
  {
    X[1] = (int)(xl-0.5f);
    <span class="keywordflow">if</span> (X[1] &lt; 0) X[1] = 0;

    X[0] = X[1]-1;
    X[2] = X[1]+1;
    X[3] = X[1]+2;

    <span class="keywordflow">if</span> (X[0] &lt; 0) X[0] = 0;
    <span class="keywordflow">if</span> (X[3] &gt; width-1) X[3] = width-1;

    t = xl - (X[1]+0.5f);
  }

  <span class="keywordflow">if</span> (yl &gt;= height-0.5)
  {
    Y[3] = Y[2] = Y[1] = height-1;
    Y[0] = Y[1]-1;
    u = 0;
  }
  <span class="keywordflow">else</span>
  {
    Y[1] = (int)(yl-0.5f);
    <span class="keywordflow">if</span> (Y[1] &lt; 0) Y[1] = 0;

    Y[0] = Y[1]-1;
    Y[2] = Y[1]+1;
    Y[3] = Y[1]+2;

    <span class="keywordflow">if</span> (Y[0] &lt; 0) Y[0] = 0;
    <span class="keywordflow">if</span> (Y[3] &gt; height-1) Y[3] = height-1;

    u = yl - (Y[1]+0.5f);
  }

  <span class="keywordtype">float</span> CX[4], CY[4];

  <span class="comment">// Optimize calculations</span>
  {
    <span class="keywordtype">float</span> c, c2, c3;

<span class="preprocessor">#define C0 (-c3 + 2.0f*c2 - c)</span>
<span class="preprocessor"></span><span class="preprocessor">#define C1 ( c3 - 2.0f*c2 + 1.0f)</span>
<span class="preprocessor"></span><span class="preprocessor">#define C2 (-c3 + c2 + c)</span>
<span class="preprocessor"></span><span class="preprocessor">#define C3 ( c3 - c2)</span>
<span class="preprocessor"></span>
    c = t;
    c2 = c*c; c3 = c2*c;
    CX[0] = C0; CX[1] = C1; CX[2] = C2; CX[3] = C3;

    c = u;
    c2 = c*c; c3 = c2*c;
    CY[0] = C0; CY[1] = C1; CY[2] = C2; CY[3] = C3;

<span class="preprocessor">#undef C0</span>
<span class="preprocessor"></span><span class="preprocessor">#undef C1</span>
<span class="preprocessor"></span><span class="preprocessor">#undef C2</span>
<span class="preprocessor"></span><span class="preprocessor">#undef C3</span>
<span class="preprocessor"></span>  }

  TU LineValue, Value;
  <span class="keywordtype">float</span> LineNorm, Norm;

  Value = 0;
  Norm = 0;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> y = 0; y &lt; 4; y++)
  {
    LineValue = 0;
    LineNorm = 0;

    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; 4; x++)
    {
      LineValue += map[Y[y]*width+X[x]] * CX[x];
      LineNorm += CX[x];
    }

    Value += LineValue * CY[y];
    Norm += CY[y] * LineNorm;
  }

  <span class="keywordflow">if</span> (Norm == 0)
  {
    Value = 0;
    <span class="keywordflow">return</span> (T)Value;
  }

  Value = (Value/Norm);

  <span class="keywordtype">int</span> size = <span class="keyword">sizeof</span>(T); 
  <span class="keywordflow">if</span> (size == 1)
    <span class="keywordflow">return</span> (T)(Value&lt;=(TU)0? (TU)0: Value&lt;=(TU)255? Value: (TU)255);
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> (T)(Value);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga9bd89a4d9aa37c684d287ba542e6cbaa"></a><!-- doxytag: member="im_math.h::imMinMax" ref="ga9bd89a4d9aa37c684d287ba542e6cbaa" args="(const T *map, int count, T &amp;min, T &amp;max, int abssolute=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imMinMax </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>abssolute</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates minimum and maximum values. </p>

<p>Referenced by <a class="el" href="group__math.html#gadcba55e31749ec46e337fe73592b5182">imMinMaxType()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (abssolute)
    min = imAbs(map[0]);
  <span class="keywordflow">else</span>
    min = map[0];

  max = min;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; count; i++)
  {
    T value;
    <span class="keywordflow">if</span> (abssolute)
      value = imAbs(map[i]);
    <span class="keywordflow">else</span>
      value = map[i];

    <span class="keywordflow">if</span> (value &gt; max)
      max = value;
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (value &lt; min)
      min = value;
  }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gadcba55e31749ec46e337fe73592b5182"></a><!-- doxytag: member="im_math.h::imMinMaxType" ref="gadcba55e31749ec46e337fe73592b5182" args="(const T *map, int count, T &amp;min, T &amp;max, int abssolute=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imMinMaxType </td>
          <td>(</td>
          <td class="paramtype">const T *&nbsp;</td>
          <td class="paramname"> <em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>abssolute</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates minimum and maximum values with addtional considerations for data type conversion and normalized operations. </p>

<p>References <a class="el" href="group__math.html#ga9bd89a4d9aa37c684d287ba542e6cbaa">imMinMax()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> size_of = <span class="keyword">sizeof</span>(imbyte);
  <span class="keywordflow">if</span> (<span class="keyword">sizeof</span>(T) == size_of)
  {
    <span class="comment">/* for imbyte is always the maximum interval */</span>
    min = 0;
    max = 255;
  }
  <span class="keywordflow">else</span>
  {
    <a class="code" href="group__math.html#ga9bd89a4d9aa37c684d287ba542e6cbaa">imMinMax</a>(map, count, min, max, abssolute);

    <span class="comment">/* if equal define a minimum interval */</span>
    <span class="keywordflow">if</span> (min == max)
    {
      max = min + 1;

      <span class="keywordflow">if</span> (min != 0)
        min = min - 1;
    }
  }
}
</pre></div></p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:07 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
