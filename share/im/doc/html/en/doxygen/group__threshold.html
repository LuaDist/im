<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: Threshold Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Threshold Operations<br/>
<small>
[<a class="el" href="group__process.html">Image Processing</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Threshold Operations:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__threshold.png" border="0" alt="" usemap="#group____threshold"/>
<map name="group____threshold" id="group____threshold">
<area shape="rect" id="node1" href="group__process.html" title="Image Processing" alt="" coords="5,5,160,37"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#gabeb0ca03378e36ed33ace4af5b4e36d9">imProcessRangeContrastThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int kernel_size, int min_range)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga0c7952abc806edd89ee981b0c9435033">imProcessLocalMaxThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int kernel_size, int min_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga77314c41838c952cb1c64d9b651c9968">imProcessThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float level, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga0111808df4575480750bba5ea1bb7fa9">imProcessThresholdByDiff</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image1, const <a class="el" href="struct__imImage.html">imImage</a> *src_image2, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga7ada706234fb5e51cff920c8d491303f">imProcessHysteresisThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int low_thres, int high_thres)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga9b3284fe7900633aaf566ff91c7106b4">imProcessHysteresisThresEstimate</a> (const <a class="el" href="struct__imImage.html">imImage</a> *image, int *low_level, int *high_level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga22fa1b4d48e642f32c0dc00b76d8b676">imProcessUniformErrThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga8a69eab40db61b8fd1264a762d8e736e">imProcessDifusionErrThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga1635181632159c6ca5d495fe052c9150">imProcessPercentThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float percent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga05c52f3c9d7a78fb887adf69e09b7173">imProcessOtsuThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#gaad37679c55dfe9cf63aa3a899d659109">imProcessMinMaxThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga8b2a8a20abb1fa5728198fae3b40a7ee">imProcessLocalMaxThresEstimate</a> (const <a class="el" href="struct__imImage.html">imImage</a> *image, int *level)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__threshold.html#ga22a76045e40b98287a1358397bfd2eda">imProcessSliceThreshold</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float start_level, float end_level)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b></b></dt><dd>Operations that converts a usually IM_GRAY/IM_BYTE image into a IM_BINARY image using several threshold techniques. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See <a class="el" href="im__process__pnt_8h.html">im_process_pnt.h</a> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabeb0ca03378e36ed33ace4af5b4e36d9"></a><!-- doxytag: member="im_process_loc.h::imProcessRangeContrastThreshold" ref="gabeb0ca03378e36ed33ace4af5b4e36d9" args="(const imImage *src_image, imImage *dst_image, int kernel_size, int min_range)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessRangeContrastThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>min_range</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Threshold using a rank convolution with a range contrast function. <br/>
 Supports all integer IM_GRAY images as source, and IM_BINARY as destiny. <br/>
 Local variable threshold by the method of Bernsen. <br/>
 Extracted from XITE, Copyright 1991, Blab, UiO <br/>
 <a href="http://www.ifi.uio.no/~blab/Software/Xite/">http://www.ifi.uio.no/~blab/Software/Xite/</a> </p>
<div class="fragment"><pre class="fragment">
  Reference:	
    Bernsen, J: "Dynamic thresholding of grey-level images"
		Proc. of the 8th ICPR, Paris, Oct 1986, 1251-1255.
  Author:     Oivind Due Trier
</pre></div><p> Returns zero if the counter aborted.</p>
<div class="fragment"><pre class="fragment">im.ProcessRangeContrastThreshold(src_image: imImage, dst_image: imImage, kernel_size: number, min_range: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessRangeContrastThresholdNew(image: imImage, kernel_size: number, min_range: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga0c7952abc806edd89ee981b0c9435033"></a><!-- doxytag: member="im_process_loc.h::imProcessLocalMaxThreshold" ref="ga0c7952abc806edd89ee981b0c9435033" args="(const imImage *src_image, imImage *dst_image, int kernel_size, int min_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessLocalMaxThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>min_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Threshold using a rank convolution with a local max function. <br/>
 Returns zero if the counter aborted. <br/>
 Supports all integer IM_GRAY images as source, and IM_BINARY as destiny.</p>
<div class="fragment"><pre class="fragment">im.ProcessLocalMaxThreshold(src_image: imImage, dst_image: imImage, kernel_size: number, min_level: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessLocalMaxThresholdNew(image: imImage, kernel_size: number, min_level: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga77314c41838c952cb1c64d9b651c9968"></a><!-- doxytag: member="im_process_pnt.h::imProcessThreshold" ref="ga77314c41838c952cb1c64d9b651c9968" args="(const imImage *src_image, imImage *dst_image, float level, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a manual threshold. <br/>
 threshold = a &lt;= level ? 0: value <br/>
 Normal value is 1 but another common value is 255. Can be done in-place for IM_BYTE source. <br/>
 Source color space must be IM_GRAY, and destiny color space must be IM_BINARY. IM_CFLOAT is not supported. <br/>
</p>
<div class="fragment"><pre class="fragment">im.ProcessThreshold(src_image: imImage, dst_image: imImage, level: number, value: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessThresholdNew(src_image: imImage, level: number, value: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga0111808df4575480750bba5ea1bb7fa9"></a><!-- doxytag: member="im_process_pnt.h::imProcessThresholdByDiff" ref="ga0111808df4575480750bba5ea1bb7fa9" args="(const imImage *src_image1, const imImage *src_image2, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessThresholdByDiff </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a threshold by the difference of two images. <br/>
 threshold = a1 &lt;= a2 ? 0: 1 <br/>
 Source color space must be IM_GRAY, and destiny color space must be IM_BINARY. IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. <br/>
</p>
<div class="fragment"><pre class="fragment">im.ProcessThresholdByDiff(src_image1: imImage, src_image2: imImage, dst_image: imImage) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessThresholdByDiffNew(src_image1: imImage, src_image2: imImage) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga7ada706234fb5e51cff920c8d491303f"></a><!-- doxytag: member="im_process_pnt.h::imProcessHysteresisThreshold" ref="ga7ada706234fb5e51cff920c8d491303f" args="(const imImage *src_image, imImage *dst_image, int low_thres, int high_thres)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessHysteresisThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>low_thres</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>high_thres</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a threshold by the Hysteresis method. <br/>
 Hysteresis thersholding of edge pixels. Starting at pixels with a value greater than the HIGH threshold, trace a connected sequence of pixels that have a value greater than the LOW threhsold. <br/>
 IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. <br/>
 Note: could not find the original source code author name.</p>
<div class="fragment"><pre class="fragment">im.ProcessHysteresisThreshold(src_image: imImage, dst_image: imImage, low_thres: number, high_thres: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessHysteresisThresholdNew(src_image: imImage, low_thres: number, high_thres: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga9b3284fe7900633aaf566ff91c7106b4"></a><!-- doxytag: member="im_process_pnt.h::imProcessHysteresisThresEstimate" ref="ga9b3284fe7900633aaf566ff91c7106b4" args="(const imImage *image, int *low_level, int *high_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessHysteresisThresEstimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>low_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>high_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Estimates hysteresis low and high threshold levels. <br/>
 Image data type can be IM_BYTE, IM_SHORT or IM_USHORT. <br/>
 Usefull for <a class="el" href="group__threshold.html#ga7ada706234fb5e51cff920c8d491303f">imProcessHysteresisThreshold</a>.</p>
<div class="fragment"><pre class="fragment">im.ProcessHysteresisThresEstimate(image: imImage) -&gt; low_level: number, high_level: number [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga22fa1b4d48e642f32c0dc00b76d8b676"></a><!-- doxytag: member="im_process_pnt.h::imProcessUniformErrThreshold" ref="ga22fa1b4d48e642f32c0dc00b76d8b676" args="(const imImage *src_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessUniformErrThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the threshold level for manual threshold using an uniform error approach. <br/>
 Supports only IM_BYTE images. Extracted from XITE, Copyright 1991, Blab, UiO <br/>
 <a href="http://www.ifi.uio.no/~blab/Software/Xite/">http://www.ifi.uio.no/~blab/Software/Xite/</a> </p>
<div class="fragment"><pre class="fragment">
  Reference:
    S. M. Dunn &amp; D. Harwood &amp; L. S. Davis:
    "Local Estimation of the Uniform Error Threshold"
    IEEE Trans. on PAMI, Vol PAMI-6, No 6, Nov 1984.
  Comments: It only works well on images whith large objects.
  Author: Olav Borgli, BLAB, ifi, UiO
  Image processing lab, Department of Informatics, University of Oslo
</pre></div><p> Returns the used level.</p>
<div class="fragment"><pre class="fragment">im.ProcessUniformErrThreshold(src_image: imImage, dst_image: imImage) -&gt; level: number [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessUniformErrThresholdNew(src_image: imImage)  -&gt; level: number, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga8a69eab40db61b8fd1264a762d8e736e"></a><!-- doxytag: member="im_process_pnt.h::imProcessDifusionErrThreshold" ref="ga8a69eab40db61b8fd1264a762d8e736e" args="(const imImage *src_image, imImage *dst_image, int level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessDifusionErrThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a dithering on each image channel by using a difusion error method. <br/>
 It can be applied on any IM_BYTE images. It will "threshold" each channel indivudually, so source and destiny must be of the same depth. Not using OpenMP when enabled.</p>
<div class="fragment"><pre class="fragment">im.ProcessDifusionErrThreshold(src_image: imImage, dst_image: imImage, level: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessDifusionErrThresholdNew(src_image: imImage, level: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga1635181632159c6ca5d495fe052c9150"></a><!-- doxytag: member="im_process_pnt.h::imProcessPercentThreshold" ref="ga1635181632159c6ca5d495fe052c9150" args="(const imImage *src_image, imImage *dst_image, float percent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessPercentThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>percent</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the threshold level for manual threshold using a percentage of pixels that should stay bellow the threshold. <br/>
 Image data type can be IM_BYTE, IM_SHORT or IM_USHORT. <br/>
 Source color space must be IM_GRAY, and destiny color space must be IM_BINARY. Returns the used level.</p>
<div class="fragment"><pre class="fragment">im.ProcessPercentThreshold(src_image: imImage, dst_image: imImage, percent: number) -&gt; level: number [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessPercentThresholdNew(src_image: imImage, percent: number) -&gt; level: number, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga05c52f3c9d7a78fb887adf69e09b7173"></a><!-- doxytag: member="im_process_pnt.h::imProcessOtsuThreshold" ref="ga05c52f3c9d7a78fb887adf69e09b7173" args="(const imImage *src_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessOtsuThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the threshold level for manual threshold using the Otsu approach. <br/>
 Image can be IM_BYTE, IM_SHORT or IM_USHORT. <br/>
 Source color space must be IM_GRAY, and destiny color space must be IM_BINARY. Returns the used level. <br/>
 Original implementation by Flavio Szenberg.</p>
<div class="fragment"><pre class="fragment">im.ProcessOtsuThreshold(src_image: imImage, dst_image: imImage) -&gt; level: number [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessOtsuThresholdNew(src_image: imImage) -&gt; level: number, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gaad37679c55dfe9cf63aa3a899d659109"></a><!-- doxytag: member="im_process_pnt.h::imProcessMinMaxThreshold" ref="gaad37679c55dfe9cf63aa3a899d659109" args="(const imImage *src_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float imProcessMinMaxThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the threshold level for manual threshold using (max-min)/2. <br/>
 Returns the used level. <br/>
 Source color space must be IM_GRAY, and destiny color space must be IM_BINARY. IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. <br/>
</p>
<div class="fragment"><pre class="fragment">im.ProcessMinMaxThreshold(src_image: imImage, dst_image: imImage) -&gt; level: number [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMinMaxThresholdNew(src_image: imImage) -&gt; level: number, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga8b2a8a20abb1fa5728198fae3b40a7ee"></a><!-- doxytag: member="im_process_pnt.h::imProcessLocalMaxThresEstimate" ref="ga8b2a8a20abb1fa5728198fae3b40a7ee" args="(const imImage *image, int *level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessLocalMaxThresEstimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Estimates Local Max threshold level for images. Image can be IM_BYTE, IM_SHORT or IM_USHORT. <br/>
</p>
<div class="fragment"><pre class="fragment">im.ProcessLocalMaxThresEstimate(image: imImage) -&gt; level: number [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga22a76045e40b98287a1358397bfd2eda"></a><!-- doxytag: member="im_process_pnt.h::imProcessSliceThreshold" ref="ga22a76045e40b98287a1358397bfd2eda" args="(const imImage *src_image, imImage *dst_image, float start_level, float end_level)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessSliceThreshold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>start_level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>end_level</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a manual threshold using an interval. <br/>
 threshold = start_level &lt;= a &lt;= end_level ? 1: 0 <br/>
 Normal value is 1 but another common value is 255. <br/>
 Source color space must be IM_GRAY, and destiny color space must be IM_BINARY. IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. <br/>
</p>
<div class="fragment"><pre class="fragment">im.ProcessSliceThreshold(src_image: imImage, dst_image: imImage, start_level: number, end_level: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessSliceThresholdNew(src_image: imImage, start_level: number, end_level: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:07 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
