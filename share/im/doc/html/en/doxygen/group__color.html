<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: Color Manipulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Color Manipulation<br/>
<small>
[<a class="el" href="group__util.html">Utilities</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Color Manipulation:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__color.png" border="0" alt="" usemap="#group____color"/>
<map name="group____color" id="group____color">
<area shape="rect" id="node3" href="group__hsi.html" title="HSI Color Coordinate System Conversions" alt="" coords="335,5,665,37"/><area shape="rect" id="node2" href="group__util.html" title="Utilities" alt="" coords="7,5,79,37"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hsi.html">HSI Color Coordinate System Conversions</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#gaf635789d379af184b54da151495bb831">imColorZeroShift</a> (int data_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#gaf173e48bd6a783395a27a17a3b8c2f2a">imColorMax</a> (int data_type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga4e00a4b0fa660bd578654ab2584f1bfe">imColorMin</a> (int data_type)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga27635c8fbb832f40533894efe7873cab">imColorQuantize</a> (const float &amp;value, const T &amp;min, const T &amp;max)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">float&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga70575ae451782c532e73ed33b5d123bb">imColorReconstruct</a> (const T &amp;value, const T &amp;min, const T &amp;max)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gab6a2e2467a202872a40bb047f01bbb18">imColorYCbCr2RGB</a> (const T Y, const T Cb, const T Cr, T &amp;R, T &amp;G, T &amp;B, const T &amp;zero, const T &amp;min, const T &amp;max)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga4f3eb018974b15a52731dc45c0868dbe">imColorRGB2YCbCr</a> (const T R, const T G, const T B, T &amp;Y, T &amp;Cb, T &amp;Cr, const T &amp;zero)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#ga673edab5600165732a568319c93fa6e0">imColorCMYK2RGB</a> (const T C, const T M, const T Y, const T K, T &amp;R, T &amp;G, T &amp;B, const T &amp;max)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gaeff11e4c11a17fc693034e8dd54f6d94">imColorXYZ2RGB</a> (const T X, const T Y, const T Z, T &amp;R, T &amp;G, T &amp;B)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gaab918cc4b5863dfb32eb00d21ecaec42">imColorRGB2XYZ</a> (const T R, const T G, const T B, T &amp;X, T &amp;Y, T &amp;Z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga87e46a03ec994de959a653a7c3ed5403">imColorXYZ2Lab</a> (const float X, const float Y, const float Z, float &amp;L, float &amp;a, float &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga84cab7a4ca4fbc02b2f72523de8edff4">imColorLab2XYZ</a> (const float L, const float a, const float b, float &amp;X, float &amp;Y, float &amp;Z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga6451122221dbe786bf919b3ac737b731">imColorXYZ2Luv</a> (const float X, const float Y, const float Z, float &amp;L, float &amp;u, float &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga71ed20a36952655c2534c8550cd5c407">imColorLuv2XYZ</a> (const float L, const float u, const float v, float &amp;X, float &amp;Y, float &amp;Z)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga2b2e18a2387f1603caf51d30bc3fd792">imColorTransfer2Linear</a> (const float &amp;nonlinear_value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#gae6841154bce52bdaa69eaa07ee541359">imColorTransfer2Nonlinear</a> (const float &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga1668579f84b8549ed3331d7ea17d7abd">imColorRGB2RGBNonlinear</a> (const float RL, const float GL, const float BL, float &amp;R, float &amp;G, float &amp;B)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__color.html#gaf1d3eaf99d26c0f6f374dc301f65fc25">imColorRGB2Luma</a> (const T R, const T G, const T B)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga0ece5fe1500273e878e11d87e6dedcbf">imColorLuminance2Lightness</a> (const float &amp;Y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__color.html#ga23498243db056e896b6e619e7a7410d2">imColorLightness2Luminance</a> (const float &amp;L)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b></b></dt><dd>Functions to convert from one color space to another, and color gammut utilities. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See <a class="el" href="im__color_8h.html">im_color.h</a></dd></dl>
<h2><a class="anchor" id="s1"></a>
Some Color Science</h2>
<dl class="user"><dt><b></b></dt><dd>Y is luminance, a linear-light quantity. It is directly proportional to physical intensity weighted by the spectral sensitivity of human vision. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>L* is lightness, a nonlinear luminance that aproximates the perception of brightness. It is nearly perceptual uniform. It has a range of 0 to 100. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Y' is luma, a nonlinear luminance that aproximates lightness. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Brightness is a visual sensation according to which an area apears to exhibit more or less light. It is a subjective quantity and can not be measured. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>One unit of euclidian distante in CIE L*u*v* or CIE L*a*b* corresponds roughly to a just-noticeable difference (JND) of color. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">
 ChromaUV = sqrt(u*u + v*v)       
 HueUV = atan2(v, u)
 SaturationUV = ChromaUV / L      (called psychometric saturation) 
 (the same can be calculated for Lab)
</pre></div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd>IEC 61966-2.1 Default RGB colour space - sRGB <ul>
<li>ITU-R Recommendation BT.709 (D65 white point). </li>
<li>D65 White Point (X,Y,Z) = (0.9505 1.0000 1.0890) </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Documentation extracted from Charles Poynton - Digital Video and HDTV - Morgan Kaufmann - 2003.</dd></dl>
<h2><a class="anchor" id="Links"></a>
Links</h2>
<ul>
<li>www.color.org - ICC </li>
<li>www.srgb.com - sRGB </li>
<li>www.poynton.com - Charles Poynton </li>
<li>www.littlecms.com - A free Color Management System (use this if you need precise color conversions)</li>
</ul>
<h2><a class="anchor" id="cci"></a>
Color Component Intervals</h2>
<dl class="user"><dt><b></b></dt><dd>When minimum and maximum values must be pre-defined values, the following values are used: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="fragment"><pre class="fragment">
 byte   [0,255]              (1 byte)
 short  [-32768,32767]       (2 bytes)
 ushort [0,65535]            (2 bytes)
 int    [-8388608,+8388607]  (3 bytes of 4 possible)
 float  [0,1]                (4 bytes)
</pre></div> Usually this intervals are used when converting from real to integer, and when demoting an integer data type. </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf635789d379af184b54da151495bb831"></a><!-- doxytag: member="im_color.h::imColorZeroShift" ref="gaf635789d379af184b54da151495bb831" args="(int data_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float imColorZeroShift </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the zero value for YCbCr color conversion. <br/>
 When data type is unsigned Cb and Cr are shifted to 0-max. So before they can be used in conversion equations Cb and Cr values must be shifted back to fix the zero position. </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> zero[] = {128.0f,     <span class="comment">// [-128,+127]</span>
                  0,      
                  32768.0f,   <span class="comment">// [-32768,+32767]</span>
                  0, 
                  0, 
                  0};      
  <span class="keywordflow">return</span> zero[data_type];
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf173e48bd6a783395a27a17a3b8c2f2a"></a><!-- doxytag: member="im_color.h::imColorMax" ref="gaf173e48bd6a783395a27a17a3b8c2f2a" args="(int data_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imColorMax </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the maximum value for pre-defined color conversion porpouses. <br/>
 See <a class="el" href="group__color.html#cci">Color Component Intervals</a>. </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> max[] = {255,      
               32767,    
               65535,    
               8388607,  
               1,        
               0};
  <span class="keywordflow">return</span> max[data_type];
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4e00a4b0fa660bd578654ab2584f1bfe"></a><!-- doxytag: member="im_color.h::imColorMin" ref="ga4e00a4b0fa660bd578654ab2584f1bfe" args="(int data_type)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imColorMin </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>data_type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the minimum value for pre-defined color conversion porpouses. <br/>
 See <a class="el" href="group__color.html#cci">Color Component Intervals</a>. </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">int</span> min[] = {0,        
               -32768,   
               0,        
               -8388608, 
               0,        
               0};
  <span class="keywordflow">return</span> min[data_type];
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga27635c8fbb832f40533894efe7873cab"></a><!-- doxytag: member="im_color.h::imColorQuantize" ref="ga27635c8fbb832f40533894efe7873cab" args="(const float &amp;value, const T &amp;min, const T &amp;max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T imColorQuantize </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Quantize 0-1 values into min-max. <br/>
 Value are usually integers, but the dummy quantizer uses real values. See also <a class="el" href="group__math.html">Math Utilities</a>. </p>

<p>References <a class="el" href="group__math.html#gab6e485874c1236f082d5c9f1457a169f">imRound()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (max == 1) <span class="keywordflow">return</span> (T)value; <span class="comment">// to allow a dummy quantizer</span>
  <span class="keywordflow">if</span> (value &gt;= 1) <span class="keywordflow">return</span> max;
  <span class="keywordflow">if</span> (value &lt;= 0) <span class="keywordflow">return</span> min;
  <span class="keywordtype">float</span> range = (float)max - (<span class="keywordtype">float</span>)min + 1.0f;
  <span class="keywordflow">return</span> (T)<a class="code" href="group__math.html#gab6e485874c1236f082d5c9f1457a169f">imRound</a>(value*range - 0.5f) + min;
}                               
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga70575ae451782c532e73ed33b5d123bb"></a><!-- doxytag: member="im_color.h::imColorReconstruct" ref="ga70575ae451782c532e73ed33b5d123bb" args="(const T &amp;value, const T &amp;min, const T &amp;max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">float imColorReconstruct </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reconstruct min-max values into 0-1. <br/>
 Values are usually integers, but the dummy reconstructor uses real values. See also <a class="el" href="group__math.html">Math Utilities</a>. </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (max == 1) <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)value;  <span class="comment">// to allow a dummy reconstructor</span>
  <span class="keywordflow">if</span> (value &lt;= min) <span class="keywordflow">return</span> 0;
  <span class="keywordflow">if</span> (value &gt;= max) <span class="keywordflow">return</span> 1;
  <span class="keywordtype">float</span> range = (float)max - (<span class="keywordtype">float</span>)min + 1.0f;
  <span class="keywordflow">return</span> (((<span class="keywordtype">float</span>)value - (<span class="keywordtype">float</span>)min + 0.5f)/range);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gab6a2e2467a202872a40bb047f01bbb18"></a><!-- doxytag: member="im_color.h::imColorYCbCr2RGB" ref="gab6a2e2467a202872a40bb047f01bbb18" args="(const T Y, const T Cb, const T Cr, T &amp;R, T &amp;G, T &amp;B, const T &amp;zero, const T &amp;min, const T &amp;max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imColorYCbCr2RGB </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>Cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>Cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>zero</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts Y'CbCr to R'G'B' (all nonlinear). <br/>
 ITU-R Recommendation 601-1 with no headroom/footroom. </p>
<div class="fragment"><pre class="fragment">
 0 &lt;= Y &lt;= 1 ; -0.5 &lt;= CbCr &lt;= 0.5 ; 0 &lt;= RGB &lt;= 1 

 R'= Y' + 0.000 *Cb + 1.402 *Cr
 G'= Y' - 0.344 *Cb - 0.714 *Cr
 B'= Y' + 1.772 *Cb + 0.000 *Cr
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> r = float(Y                        + 1.402f * (Cr - zero));
  <span class="keywordtype">float</span> g = float(Y - 0.344f * (Cb - zero) - 0.714f * (Cr - zero));
  <span class="keywordtype">float</span> b = float(Y + 1.772f * (Cb - zero));

  <span class="comment">// now we should enforce min &lt;= rgb &lt;= max</span>
  R = (T)IM_CROPMINMAX(r, min, max);
  G = (T)IM_CROPMINMAX(g, min, max);
  B = (T)IM_CROPMINMAX(b, min, max);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga4f3eb018974b15a52731dc45c0868dbe"></a><!-- doxytag: member="im_color.h::imColorRGB2YCbCr" ref="ga4f3eb018974b15a52731dc45c0868dbe" args="(const T R, const T G, const T B, T &amp;Y, T &amp;Cb, T &amp;Cr, const T &amp;zero)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imColorRGB2YCbCr </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>Cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>Cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>zero</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts R'G'B' to Y'CbCr (all nonlinear). <br/>
 ITU-R Recommendation 601-1 with no headroom/footroom. </p>
<div class="fragment"><pre class="fragment">
 0 &lt;= Y &lt;= 1 ; -0.5 &lt;= CbCr &lt;= 0.5 ; 0 &lt;= RGB &lt;= 1 

 Y' =  0.299 *R' + 0.587 *G' + 0.114 *B'
 Cb = -0.169 *R' - 0.331 *G' + 0.500 *B'
 Cr =  0.500 *R' - 0.419 *G' - 0.081 *B'
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  Y  = (T)( 0.299f *R + 0.587f *G + 0.114f *B);
  Cb = (T)(-0.169f *R - 0.331f *G + 0.500f *B + (<span class="keywordtype">float</span>)zero);
  Cr = (T)( 0.500f *R - 0.419f *G - 0.081f *B + (<span class="keywordtype">float</span>)zero);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga673edab5600165732a568319c93fa6e0"></a><!-- doxytag: member="im_color.h::imColorCMYK2RGB" ref="ga673edab5600165732a568319c93fa6e0" args="(const T C, const T M, const T Y, const T K, T &amp;R, T &amp;G, T &amp;B, const T &amp;max)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imColorCMYK2RGB </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>max</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts C'M'Y'K' to R'G'B' (all nonlinear). <br/>
 This is a poor conversion that works for a simple visualization. </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= CMYK &lt;= 1 ; 0 &lt;= RGB &lt;= 1 

  R = (1 - K) * (1 - C)
  G = (1 - K) * (1 - M)
  B = (1 - K) * (1 - Y)
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  T W = max - K;
  R = (T)((W * (max - C)) / max);
  G = (T)((W * (max - M)) / max);
  B = (T)((W * (max - Y)) / max);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaeff11e4c11a17fc693034e8dd54f6d94"></a><!-- doxytag: member="im_color.h::imColorXYZ2RGB" ref="gaeff11e4c11a17fc693034e8dd54f6d94" args="(const T X, const T Y, const T Z, T &amp;R, T &amp;G, T &amp;B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imColorXYZ2RGB </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts CIE XYZ to Rec 709 RGB (all linear). <br/>
 ITU-R Recommendation BT.709 (D65 white point). <br/>
 </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= XYZ &lt;= 1 ; 0 &lt;= RGB &lt;= 1    

  R =  3.2406 *X - 1.5372 *Y - 0.4986 *Z
  G = -0.9689 *X + 1.8758 *Y + 0.0415 *Z
  B =  0.0557 *X - 0.2040 *Y + 1.0570 *Z
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> r =  3.2406f *X - 1.5372f *Y - 0.4986f *Z;
  <span class="keywordtype">float</span> g = -0.9689f *X + 1.8758f *Y + 0.0415f *Z;
  <span class="keywordtype">float</span> b =  0.0557f *X - 0.2040f *Y + 1.0570f *Z;

  <span class="comment">// we need to crop because not all XYZ colors are visible</span>
  R = (T)IM_FLOATCROP(r);
  G = (T)IM_FLOATCROP(g);
  B = (T)IM_FLOATCROP(b);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaab918cc4b5863dfb32eb00d21ecaec42"></a><!-- doxytag: member="im_color.h::imColorRGB2XYZ" ref="gaab918cc4b5863dfb32eb00d21ecaec42" args="(const T R, const T G, const T B, T &amp;X, T &amp;Y, T &amp;Z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void imColorRGB2XYZ </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>Z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts Rec 709 RGB to CIE XYZ (all linear). <br/>
 ITU-R Recommendation BT.709 (D65 white point). <br/>
 </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= XYZ &lt;= 1 ; 0 &lt;= RGB &lt;= 1    

  X = 0.4124 *R + 0.3576 *G + 0.1805 *B
  Y = 0.2126 *R + 0.7152 *G + 0.0722 *B
  Z = 0.0193 *R + 0.1192 *G + 0.9505 *B
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  X = (T)(0.4124f *R + 0.3576f *G + 0.1805f *B);
  Y = (T)(0.2126f *R + 0.7152f *G + 0.0722f *B);
  Z = (T)(0.0193f *R + 0.1192f *G + 0.9505f *B);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga87e46a03ec994de959a653a7c3ed5403"></a><!-- doxytag: member="im_color.h::imColorXYZ2Lab" ref="ga87e46a03ec994de959a653a7c3ed5403" args="(const float X, const float Y, const float Z, float &amp;L, float &amp;a, float &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imColorXYZ2Lab </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts CIE XYZ (linear) to CIE L*a*b* (nonlinear). <br/>
 The white point is D65. <br/>
 </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= L &lt;= 1 ; -0.5 &lt;= ab &lt;= +0.5 ; 0 &lt;= XYZ &lt;= 1 

  if (t &gt; 0.008856)
    f(t) = pow(t, 1/3)
  else
    f(t) = 7.787*t + 16/116

  fX = f(X / Xn)      fY = f(Y / Yn)      fZ = f(Z / Zn)

  L = 1.16 * fY - 0.16
  a = 2.5 * (fX - fY)
  b = (fY - fZ)

</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> fX = X / 0.9505f;  <span class="comment">// white point D65</span>
  <span class="keywordtype">float</span> fY = Y / 1.0f;
  <span class="keywordtype">float</span> fZ = Z / 1.0890f;

  fX = IM_FWLAB(fX);
  fY = IM_FWLAB(fY);
  fZ = IM_FWLAB(fZ);

  L = 1.16f * fY - 0.16f;
  a = 2.5f * (fX - fY);
  b = (fY - fZ);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga84cab7a4ca4fbc02b2f72523de8edff4"></a><!-- doxytag: member="im_color.h::imColorLab2XYZ" ref="ga84cab7a4ca4fbc02b2f72523de8edff4" args="(const float L, const float a, const float b, float &amp;X, float &amp;Y, float &amp;Z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imColorLab2XYZ </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>Z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts CIE L*a*b* (nonlinear) to CIE XYZ (linear). <br/>
 The white point is D65. <br/>
 0 &lt;= L &lt;= 1 ; -0.5 &lt;= ab &lt;= +0.5 ; 0 &lt;= XYZ &lt;= 1 </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> fY = (L + 0.16f) / 1.16f;
  <span class="keywordtype">float</span> gY = IM_GWLAB(fY);

  <span class="keywordtype">float</span> fgY = IM_FWLAB(gY);
  <span class="keywordtype">float</span> gX = fgY + a / 2.5f;
  <span class="keywordtype">float</span> gZ = fgY - b;
  gX = IM_GWLAB(gX);
  gZ = IM_GWLAB(gZ);

  X = gX * 0.9505f;     <span class="comment">// white point D65</span>
  Y = gY * 1.0f;
  Z = gZ * 1.0890f;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga6451122221dbe786bf919b3ac737b731"></a><!-- doxytag: member="im_color.h::imColorXYZ2Luv" ref="ga6451122221dbe786bf919b3ac737b731" args="(const float X, const float Y, const float Z, float &amp;L, float &amp;u, float &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imColorXYZ2Luv </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts CIE XYZ (linear) to CIE L*u*v* (nonlinear). <br/>
 The white point is D65. <br/>
 </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= L &lt;= 1 ; -1 &lt;= uv &lt;= +1 ; 0 &lt;= XYZ &lt;= 1

  Y = Y / 1.0      (for D65)
  if (Y &gt; 0.008856)
    fY = pow(Y, 1/3)
  else
    fY = 7.787 * Y + 0.16/1.16
  L = 1.16 * fY - 0.16

  U(x, y, z) = (4 * x)/(x + 15 * y + 3 * z)
  V(x, y, z) = (9 * x)/(x + 15 * y + 3 * z)
  un = U(Xn, Yn, Zn) = 0.1978      (for D65)
  vn = V(Xn, Yn, Zn) = 0.4683      (for D65)
  fu = U(X, Y, Z) 
  fv = V(X, Y, Z) 

  u = 13 * L * (fu - un)
  v = 13 * L * (fv - vn)
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> XYZ = (float)(X + 15 * Y + 3 * Z);
  <span class="keywordtype">float</span> fY = Y / 1.0f;

  <span class="keywordflow">if</span> (XYZ != 0)
  {
    L = 1.16f * IM_FWLAB(fY) - 0.16f;
    u = 6.5f * L * ((4 * X)/XYZ - 0.1978f);
    v = 6.5f * L * ((9 * Y)/XYZ - 0.4683f);
  }
  <span class="keywordflow">else</span>
  {
    L = u = v = 0;
  }
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga71ed20a36952655c2534c8550cd5c407"></a><!-- doxytag: member="im_color.h::imColorLuv2XYZ" ref="ga71ed20a36952655c2534c8550cd5c407" args="(const float L, const float u, const float v, float &amp;X, float &amp;Y, float &amp;Z)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imColorLuv2XYZ </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>Z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts CIE L*u*v* (nonlinear) to CIE XYZ (linear). <br/>
 The white point is D65. 0 &lt;= L &lt;= 1 ; -0.5 &lt;= uv &lt;= +0.5 ; 0 &lt;= XYZ &lt;= 1 <br/>
 </p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> fY = (L + 0.16f) / 1.16f;
  Y = IM_GWLAB(fY) * 1.0f;

  <span class="keywordtype">float</span> ul = 0.1978f, vl = 0.4683f;
  <span class="keywordflow">if</span> (L != 0)
  {
    ul = u / (6.5f * L) + 0.1978f;
    vl = v / (6.5f * L) + 0.4683f;
  }

  X = ((9 * ul) / (4 * vl)) * Y;
  Z = ((12 - 3 * ul - 20 * vl) / (4 * vl)) * Y;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga2b2e18a2387f1603caf51d30bc3fd792"></a><!-- doxytag: member="im_color.h::imColorTransfer2Linear" ref="ga2b2e18a2387f1603caf51d30bc3fd792" args="(const float &amp;nonlinear_value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float imColorTransfer2Linear </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>nonlinear_value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts nonlinear values to linear values. <br/>
 We use the sRGB transfer function. sRGB uses ITU-R 709 primaries and D65 white point. <br/>
 </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= l &lt;= 1 ; 0 &lt;= v &lt;= 1 

  if (v &lt; 0.03928)
    l = v / 12.92
  else
    l = pow((v + 0.055) / 1.055, 2.4)
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (nonlinear_value &lt; 0.03928f)
    <span class="keywordflow">return</span> nonlinear_value / 12.92f;
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> powf((nonlinear_value + 0.055f) / 1.055f, 2.4f);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae6841154bce52bdaa69eaa07ee541359"></a><!-- doxytag: member="im_color.h::imColorTransfer2Nonlinear" ref="gae6841154bce52bdaa69eaa07ee541359" args="(const float &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float imColorTransfer2Nonlinear </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts linear values to nonlinear values. <br/>
 We use the sRGB transfer function. sRGB uses ITU-R 709 primaries and D65 white point. <br/>
 </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= l &lt;= 1 ; 0 &lt;= v &lt;= 1 

  if (l &lt; 0.0031308)
    v = 12.92 * l
  else
    v = 1.055 * pow(l, 1/2.4) - 0.055
</pre></div> 
<p>Referenced by <a class="el" href="group__color.html#ga1668579f84b8549ed3331d7ea17d7abd">imColorRGB2RGBNonlinear()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">if</span> (value &lt; 0.0031308f)
    <span class="keywordflow">return</span> 12.92f * value;
  <span class="keywordflow">else</span>
    <span class="keywordflow">return</span> 1.055f * powf(value, 1.0f/2.4f) - 0.055f;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga1668579f84b8549ed3331d7ea17d7abd"></a><!-- doxytag: member="im_color.h::imColorRGB2RGBNonlinear" ref="ga1668579f84b8549ed3331d7ea17d7abd" args="(const float RL, const float GL, const float BL, float &amp;R, float &amp;G, float &amp;B)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imColorRGB2RGBNonlinear </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>RL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>GL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>BL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts RGB (linear) to R'G'B' (nonlinear). </p>

<p>References <a class="el" href="group__color.html#gae6841154bce52bdaa69eaa07ee541359">imColorTransfer2Nonlinear()</a>.</p>

<p><div class="fragment"><pre class="fragment">{
  R = <a class="code" href="group__color.html#gae6841154bce52bdaa69eaa07ee541359">imColorTransfer2Nonlinear</a>(RL);
  G = <a class="code" href="group__color.html#gae6841154bce52bdaa69eaa07ee541359">imColorTransfer2Nonlinear</a>(GL);
  B = <a class="code" href="group__color.html#gae6841154bce52bdaa69eaa07ee541359">imColorTransfer2Nonlinear</a>(BL);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="gaf1d3eaf99d26c0f6f374dc301f65fc25"></a><!-- doxytag: member="im_color.h::imColorRGB2Luma" ref="gaf1d3eaf99d26c0f6f374dc301f65fc25" args="(const T R, const T G, const T B)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T imColorRGB2Luma </td>
          <td>(</td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&nbsp;</td>
          <td class="paramname"> <em>B</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts R'G'B' to Y' (all nonlinear). <br/>
 </p>
<div class="fragment"><pre class="fragment">
 Y'  =  0.299 *R' + 0.587 *G' + 0.114 *B'
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> (T)((299 * R + 587 * G + 114 * B) / 1000);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga0ece5fe1500273e878e11d87e6dedcbf"></a><!-- doxytag: member="im_color.h::imColorLuminance2Lightness" ref="ga0ece5fe1500273e878e11d87e6dedcbf" args="(const float &amp;Y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float imColorLuminance2Lightness </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>Y</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts Luminance (CIE Y) to Lightness (CIE L*) (all linear). <br/>
 The white point is D65. </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= Y &lt;= 1 ; 0 &lt;= L* &lt;= 1

  Y = Y / 1.0      (for D65)
  if (Y &gt; 0.008856)
    fY = pow(Y, 1/3)
  else
    fY = 7.787 * Y + 0.16/1.16
  L = 1.16 * fY - 0.16
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordflow">return</span> 1.16f * IM_FWLAB(Y) - 0.16f;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="ga23498243db056e896b6e619e7a7410d2"></a><!-- doxytag: member="im_color.h::imColorLightness2Luminance" ref="ga23498243db056e896b6e619e7a7410d2" args="(const float &amp;L)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float imColorLightness2Luminance </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&nbsp;</td>
          <td class="paramname"> <em>L</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Converts Lightness (CIE L*) to Luminance (CIE Y) (all linear). <br/>
 The white point is D65. </p>
<div class="fragment"><pre class="fragment">
  0 &lt;= Y &lt;= 1 ; 0 &lt;= L* &lt;= 1

  fY = (L + 0.16)/1.16
  if (fY &gt; 0.20689)
    Y = pow(fY, 3)
  else
    Y = 0.1284 * (fY - 0.16/1.16)
  Y = Y * 1.0      (for D65)
</pre></div> 
<p><div class="fragment"><pre class="fragment">{
  <span class="keywordtype">float</span> fY = (L + 0.16f) / 1.16f;
  <span class="keywordflow">return</span> IM_GWLAB(fY);
}
</pre></div></p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:07 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
