<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: im_process_ana.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="headertitle">
<h1>im_process_ana.h</h1>  </div>
</div>
<div class="contents">
<a href="im__process__ana_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** \file</span>
<a name="l00002"></a>00002 <span class="comment"> * \brief Image Statistics and Analysis</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * See Copyright Notice in im_lib.h</span>
<a name="l00005"></a>00005 <span class="comment"> */</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#ifndef __IM_PROC_ANA_H</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#define __IM_PROC_ANA_H</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="im__image_8h.html" title="Image Manipulation.">im_image.h</a>&quot;</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#if     defined(__cplusplus)</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00014"></a>00014 <span class="preprocessor">#endif</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="comment">/** \defgroup stats Image Statistics</span>
<a name="l00019"></a>00019 <span class="comment"> * \par</span>
<a name="l00020"></a>00020 <span class="comment"> * Operations to calculate some statistics over images.</span>
<a name="l00021"></a>00021 <span class="comment"> * \par</span>
<a name="l00022"></a>00022 <span class="comment"> * See \ref im_process_ana.h</span>
<a name="l00023"></a>00023 <span class="comment"> * \ingroup process */</span>
<a name="l00024"></a>00024 <span class="comment"></span>
<a name="l00025"></a>00025 <span class="comment">/** Calculates the RMS error between two images (Root Mean Square Error).</span>
<a name="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027"></a>00027 <span class="comment"> * \verbatim im.CalcRMSError(image1: imImage, image2: imImage) -&gt; rms: number [in Lua 5] \endverbatim</span>
<a name="l00028"></a>00028 <span class="comment"> * \ingroup stats */</span>
<a name="l00029"></a>00029 <span class="keywordtype">float</span> <a class="code" href="group__stats.html#gac9ef4831687d78d25d413ed92389026c">imCalcRMSError</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image2);
<a name="l00030"></a>00030 <span class="comment"></span>
<a name="l00031"></a>00031 <span class="comment">/** Calculates the SNR of an image and its noise (Signal Noise Ratio).</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> * \verbatim im.CalcSNR(src_image: imImage, noise_image: imImage) -&gt; snr: number [in Lua 5] \endverbatim</span>
<a name="l00034"></a>00034 <span class="comment"> * \ingroup stats */</span>
<a name="l00035"></a>00035 <span class="keywordtype">float</span> <a class="code" href="group__stats.html#ga0d73010aaae19890197f949b950dc330">imCalcSNR</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* noise_image);
<a name="l00036"></a>00036 <span class="comment"></span>
<a name="l00037"></a>00037 <span class="comment">/** Count the number of different colors in an image. \n</span>
<a name="l00038"></a>00038 <span class="comment"> * Image must be IM_BYTE, but can has all color spaces except IM_CMYK.</span>
<a name="l00039"></a>00039 <span class="comment"> * Data type can be also IM_SHORT or IM_USHORT if color space is IM_GRAY, IM_BINARY or IM_MAP.</span>
<a name="l00040"></a>00040 <span class="comment"> * Not using OpenMP when enabled, when color space depth is greater than 1.</span>
<a name="l00041"></a>00041 <span class="comment"> *</span>
<a name="l00042"></a>00042 <span class="comment"> * \verbatim im.CalcCountColors(image: imImage) -&gt; count: number [in Lua 5] \endverbatim</span>
<a name="l00043"></a>00043 <span class="comment"> * \ingroup stats */</span>
<a name="l00044"></a>00044 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="group__stats.html#ga33e57c5aaee2c88059114421a8d9abe5">imCalcCountColors</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image);
<a name="l00045"></a>00045 <span class="comment"></span>
<a name="l00046"></a>00046 <span class="comment">/** Calculates the gray histogram of an image. \n</span>
<a name="l00047"></a>00047 <span class="comment"> * Image must be (IM_BYTE, IM_SHORT or IM_USHORT)/(IM_RGB, IM_GRAY, IM_BINARY or IM_MAP). \n</span>
<a name="l00048"></a>00048 <span class="comment"> * If the image is IM_RGB then the histogram of the luma component is calculated. \n</span>
<a name="l00049"></a>00049 <span class="comment"> * Histogram is always 256 or 65536 positions long. \n</span>
<a name="l00050"></a>00050 <span class="comment"> * When cumulative is different from zero it calculates the cumulative histogram.</span>
<a name="l00051"></a>00051 <span class="comment"> *</span>
<a name="l00052"></a>00052 <span class="comment"> * \verbatim im.CalcGrayHistogram(image: imImage, cumulative: boolean) -&gt; histo: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00053"></a>00053 <span class="comment"> * \ingroup stats */</span>
<a name="l00054"></a>00054 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#gaa49ebea65178d5f7e2c07e1f7c5be5b9">imCalcGrayHistogram</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* histo, <span class="keywordtype">int</span> cumulative);
<a name="l00055"></a>00055 <span class="comment"></span>
<a name="l00056"></a>00056 <span class="comment">/** Calculates the histogram of an image plane. \n</span>
<a name="l00057"></a>00057 <span class="comment"> * Image can be IM_BYTE, IM_SHORT or IM_USHORT. \n</span>
<a name="l00058"></a>00058 <span class="comment"> * Histogram is always 256 or 65536 positions long. \n</span>
<a name="l00059"></a>00059 <span class="comment"> * Where plane is the depth plane to calculate the histogram. \n</span>
<a name="l00060"></a>00060 <span class="comment"> * When cumulative is different from zero it calculates the cumulative histogram.</span>
<a name="l00061"></a>00061 <span class="comment"> *</span>
<a name="l00062"></a>00062 <span class="comment"> * \verbatim im.CalcHistogram(image: imImage, plane: number, cumulative: boolean) -&gt; histo: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00063"></a>00063 <span class="comment"> * The returned table is zero indexed.</span>
<a name="l00064"></a>00064 <span class="comment"> * \ingroup stats */</span>
<a name="l00065"></a>00065 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#gae232f0dc28a7e3e04b8e71ead9d1b509">imCalcHistogram</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* histo, <span class="keywordtype">int</span> plane, <span class="keywordtype">int</span> cumulative);
<a name="l00066"></a>00066 <span class="comment"></span>
<a name="l00067"></a>00067 <span class="comment">/** Calculates the histogram of a IM_BYTE data. \n</span>
<a name="l00068"></a>00068 <span class="comment"> * Histogram is always 256 positions long. \n</span>
<a name="l00069"></a>00069 <span class="comment"> * When cumulative is different from zero it calculates the cumulative histogram.</span>
<a name="l00070"></a>00070 <span class="comment"> * Not available in Lua.</span>
<a name="l00071"></a>00071 <span class="comment"> * \ingroup stats */</span>
<a name="l00072"></a>00072 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#ga6c9740c320360c645b71e8c65efcfc73">imCalcByteHistogram</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* data, <span class="keywordtype">int</span> count, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* histo, <span class="keywordtype">int</span> cumulative);
<a name="l00073"></a>00073 <span class="comment"></span>
<a name="l00074"></a>00074 <span class="comment">/** Calculates the histogram of a IM_USHORT data. \n</span>
<a name="l00075"></a>00075 <span class="comment"> * Histogram is always 65536 positions long. \n</span>
<a name="l00076"></a>00076 <span class="comment"> * When cumulative is different from zero it calculates the cumulative histogram. \n</span>
<a name="l00077"></a>00077 <span class="comment"> * Not available in Lua.</span>
<a name="l00078"></a>00078 <span class="comment"> * \ingroup stats */</span>
<a name="l00079"></a>00079 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#gaf6b60bf22388aeae3a2ee5a3e7116493">imCalcUShortHistogram</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* data, <span class="keywordtype">int</span> count, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* histo, <span class="keywordtype">int</span> cumulative);
<a name="l00080"></a>00080 <span class="comment"></span>
<a name="l00081"></a>00081 <span class="comment">/** Calculates the histogram of a IM_SHORT data. \n</span>
<a name="l00082"></a>00082 <span class="comment"> * Histogram is always 65536 positions long. \n</span>
<a name="l00083"></a>00083 <span class="comment"> * Zero is located at 32768 index. \n</span>
<a name="l00084"></a>00084 <span class="comment"> * When cumulative is different from zero it calculates the cumulative histogram. \n</span>
<a name="l00085"></a>00085 <span class="comment"> * Not available in Lua.</span>
<a name="l00086"></a>00086 <span class="comment"> * \ingroup stats */</span>
<a name="l00087"></a>00087 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#ga96528aa1738fd1fd170ed284075c9d79">imCalcShortHistogram</a>(<span class="keyword">const</span> <span class="keywordtype">short</span>* data, <span class="keywordtype">int</span> count, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* histo, <span class="keywordtype">int</span> cumulative);
<a name="l00088"></a>00088 <span class="comment"></span>
<a name="l00089"></a>00089 <span class="comment">/** Alocates an histogram data based on the image data type. \n</span>
<a name="l00090"></a>00090 <span class="comment"> * Not available in Lua.</span>
<a name="l00091"></a>00091 <span class="comment"> * \ingroup stats */</span>
<a name="l00092"></a>00092 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* <a class="code" href="group__stats.html#ga366c4b64930ab796e08d39443115f85d">imHistogramNew</a>(<span class="keywordtype">int</span> data_type, <span class="keywordtype">int</span> *hcount);
<a name="l00093"></a>00093 <span class="comment"></span>
<a name="l00094"></a>00094 <span class="comment">/** Releases the histogram data. \n</span>
<a name="l00095"></a>00095 <span class="comment"> * Not available in Lua.</span>
<a name="l00096"></a>00096 <span class="comment"> * \ingroup stats */</span>
<a name="l00097"></a>00097 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#ga7e02a632eeb2186e666aa5380094309b">imHistogramRelease</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* histo);
<a name="l00098"></a>00098 <span class="comment"></span>
<a name="l00099"></a>00099 <span class="comment">/** Short data type stores the histogram values of negative indices starting at 0.</span>
<a name="l00100"></a>00100 <span class="comment"> * So the real level is obtained by shifting the zero based index. \n</span>
<a name="l00101"></a>00101 <span class="comment"> * Not available in Lua.</span>
<a name="l00102"></a>00102 <span class="comment"> * \ingroup stats */</span>
<a name="l00103"></a>00103 <span class="keywordtype">int</span> <a class="code" href="group__stats.html#ga28f4976a6797c6720586e762115dd3dc">imHistogramShift</a>(<span class="keywordtype">int</span> data_type);
<a name="l00104"></a>00104 <span class="comment"></span>
<a name="l00105"></a>00105 <span class="comment">/** Returns the histogram size based on the image data type. \n</span>
<a name="l00106"></a>00106 <span class="comment"> * Not available in Lua.</span>
<a name="l00107"></a>00107 <span class="comment"> * \ingroup stats */</span>
<a name="l00108"></a>00108 <span class="keywordtype">int</span> <a class="code" href="group__stats.html#gac035431b4f96b0945491c498b607726e">imHistogramCount</a>(<span class="keywordtype">int</span> data_type);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111 <span class="comment">/** \brief Numerical Statistics Structure</span>
<a name="l00112"></a>00112 <span class="comment"> * \ingroup stats */</span>
<a name="l00113"></a><a class="code" href="struct__imStats.html">00113</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="struct__imStats.html" title="Numerical Statistics Structure.">_imStats</a>
<a name="l00114"></a>00114 {
<a name="l00115"></a><a class="code" href="struct__imStats.html#aa6d973b5da30235d59713fb762534000">00115</a>   <span class="keywordtype">float</span> <a class="code" href="struct__imStats.html#aa6d973b5da30235d59713fb762534000">max</a>;                <span class="comment">/**&lt; Maximum value              */</span>
<a name="l00116"></a><a class="code" href="struct__imStats.html#aedcfb56b3b19bbb8071dfa4af80f8879">00116</a>   <span class="keywordtype">float</span> <a class="code" href="struct__imStats.html#aedcfb56b3b19bbb8071dfa4af80f8879">min</a>;                <span class="comment">/**&lt; Minimum value              */</span>
<a name="l00117"></a><a class="code" href="struct__imStats.html#a983fe3d1f3cd3ae55d060a6a868924da">00117</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="struct__imStats.html#a983fe3d1f3cd3ae55d060a6a868924da">positive</a>;   <span class="comment">/**&lt; Number of Positive Values  */</span>
<a name="l00118"></a><a class="code" href="struct__imStats.html#a1f4272b7a0d51980dfa398bb3a6bd0b1">00118</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="struct__imStats.html#a1f4272b7a0d51980dfa398bb3a6bd0b1">negative</a>;   <span class="comment">/**&lt; Number of Negative Values  */</span>
<a name="l00119"></a><a class="code" href="struct__imStats.html#a55b7d17660c9c25146468b1bcccf6e5b">00119</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="struct__imStats.html#a55b7d17660c9c25146468b1bcccf6e5b">zeros</a>;      <span class="comment">/**&lt; Number of Zeros            */</span>
<a name="l00120"></a><a class="code" href="struct__imStats.html#a6007de54eca963a3f9bc9fdd6cc38f2e">00120</a>   <span class="keywordtype">float</span> <a class="code" href="struct__imStats.html#a6007de54eca963a3f9bc9fdd6cc38f2e">mean</a>;               <span class="comment">/**&lt; Mean                       */</span>
<a name="l00121"></a><a class="code" href="struct__imStats.html#a7d1506df75927641900dc67dc8c2ac2b">00121</a>   <span class="keywordtype">float</span> <a class="code" href="struct__imStats.html#a7d1506df75927641900dc67dc8c2ac2b">stddev</a>;             <span class="comment">/**&lt; Standard Deviation         */</span>
<a name="l00122"></a>00122 } <a class="code" href="struct__imStats.html" title="Numerical Statistics Structure.">imStats</a>;
<a name="l00123"></a>00123 <span class="comment"></span>
<a name="l00124"></a>00124 <span class="comment">/** Calculates the statistics about the image data. \n</span>
<a name="l00125"></a>00125 <span class="comment"> * There is one stats for each depth plane. For ex: stats[0]=red stats, stats[0]=green stats, ... \n</span>
<a name="l00126"></a>00126 <span class="comment"> * Supports all data types except IM_CFLOAT. \n</span>
<a name="l00127"></a>00127 <span class="comment"> *</span>
<a name="l00128"></a>00128 <span class="comment"> * \verbatim im.CalcImageStatistics(image: imImage) -&gt; stats: table [in Lua 5] \endverbatim</span>
<a name="l00129"></a>00129 <span class="comment"> * Table contains the following fields: max, min, positive, negative, zeros, mean, stddev. </span>
<a name="l00130"></a>00130 <span class="comment"> * If image depth &gt; 1 then table contains several tables with the previous fields, one for each plane,</span>
<a name="l00131"></a>00131 <span class="comment"> * starting at 0.</span>
<a name="l00132"></a>00132 <span class="comment"> * The same as the \ref imStats structure.</span>
<a name="l00133"></a>00133 <span class="comment"> * \ingroup stats */</span>
<a name="l00134"></a>00134 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#ga54c100ff63275431cb447c6baf95a81a">imCalcImageStatistics</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <a class="code" href="struct__imStats.html" title="Numerical Statistics Structure.">imStats</a>* stats);
<a name="l00135"></a>00135 <span class="comment"></span>
<a name="l00136"></a>00136 <span class="comment">/** Calculates the statistics about the image histogram data.\n</span>
<a name="l00137"></a>00137 <span class="comment"> * There is one stats for each depth plane. For ex: stats[0]=red stats, stats[0]=green stats, ... \n</span>
<a name="l00138"></a>00138 <span class="comment"> * Only IM_BYTE, IM_SHORT and IM_USHORT images are supported.</span>
<a name="l00139"></a>00139 <span class="comment"> *</span>
<a name="l00140"></a>00140 <span class="comment"> * \verbatim im.CalcHistogramStatistics(image: imImage) -&gt; stats: table [in Lua 5] \endverbatim</span>
<a name="l00141"></a>00141 <span class="comment"> * \ingroup stats */</span>
<a name="l00142"></a>00142 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#gad3c9348c767f07203f01c1315a88c809">imCalcHistogramStatistics</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <a class="code" href="struct__imStats.html" title="Numerical Statistics Structure.">imStats</a>* stats);
<a name="l00143"></a>00143 <span class="comment"></span>
<a name="l00144"></a>00144 <span class="comment">/** Calculates some extra statistics about the image histogram data.\n</span>
<a name="l00145"></a>00145 <span class="comment"> * There is one stats for each depth plane. \n</span>
<a name="l00146"></a>00146 <span class="comment"> * Only IM_BYTE, IM_SHORT and IM_USHORT images are supported. \n</span>
<a name="l00147"></a>00147 <span class="comment"> * mode will be -1 if more than one max is found.</span>
<a name="l00148"></a>00148 <span class="comment"> *</span>
<a name="l00149"></a>00149 <span class="comment"> * \verbatim im.CalcHistoImageStatistics(image: imImage) -&gt; median: number, mode: number [in Lua 5] \endverbatim</span>
<a name="l00150"></a>00150 <span class="comment"> * \ingroup stats */</span>
<a name="l00151"></a>00151 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#ga5360508cdce83a0d405cb4b0529174e5">imCalcHistoImageStatistics</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span>* median, <span class="keywordtype">int</span>* mode);
<a name="l00152"></a>00152 <span class="comment"></span>
<a name="l00153"></a>00153 <span class="comment">/** Calculates the minimum and maximum levels </span>
<a name="l00154"></a>00154 <span class="comment"> * ignoring a given percentage of the histogram count.\n</span>
<a name="l00155"></a>00155 <span class="comment"> * Only IM_BYTE, IM_SHORT and IM_USHORT images are supported. \n</span>
<a name="l00156"></a>00156 <span class="comment"> *</span>
<a name="l00157"></a>00157 <span class="comment"> * \verbatim im.CalcPercentMinMax(image: imImage, percent: number, ignore_zero: boolean) -&gt; min, max: number [in Lua 5] \endverbatim</span>
<a name="l00158"></a>00158 <span class="comment"> * \ingroup stats */</span>
<a name="l00159"></a>00159 <span class="keywordtype">void</span> <a class="code" href="group__stats.html#gad38d7c053557626a14073a08627411a6">imCalcPercentMinMax</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span> percent, <span class="keywordtype">int</span> ignore_zero, <span class="keywordtype">int</span> *min, <span class="keywordtype">int</span> *max);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment"></span>
<a name="l00162"></a>00162 <span class="comment">/** \defgroup analyze Image Analysis</span>
<a name="l00163"></a>00163 <span class="comment"> * \par</span>
<a name="l00164"></a>00164 <span class="comment"> * See \ref im_process_ana.h</span>
<a name="l00165"></a>00165 <span class="comment"> * \ingroup process */</span>
<a name="l00166"></a>00166 <span class="comment"></span>
<a name="l00167"></a>00167 <span class="comment">/** Find white regions in binary image. \n</span>
<a name="l00168"></a>00168 <span class="comment"> * Result is IM_GRAY/IM_USHORT type. Regions can be 4 connected or 8 connected. \n</span>
<a name="l00169"></a>00169 <span class="comment"> * Returns the number of regions found. Background is marked as 0. \n</span>
<a name="l00170"></a>00170 <span class="comment"> * Regions touching the border are considered only if touch_border=1.</span>
<a name="l00171"></a>00171 <span class="comment"> * Not using OpenMP when enabled.</span>
<a name="l00172"></a>00172 <span class="comment"> *</span>
<a name="l00173"></a>00173 <span class="comment"> * \verbatim im.AnalyzeFindRegions(src_image: imImage, dst_image: imImage, connect: number, touch_border: boolean) -&gt; count: number [in Lua 5] \endverbatim</span>
<a name="l00174"></a>00174 <span class="comment"> * \verbatim im.AnalyzeFindRegionsNew(image: imImage, connect: number, touch_border: boolean) -&gt; count: number, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00175"></a>00175 <span class="comment"> * \ingroup analyze */</span>
<a name="l00176"></a>00176 <span class="keywordtype">int</span> <a class="code" href="group__analyze.html#gaaaf65c8684859c29d317d9546c0a8ca4">imAnalyzeFindRegions</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> connect, <span class="keywordtype">int</span> touch_border);
<a name="l00177"></a>00177 <span class="comment"></span>
<a name="l00178"></a>00178 <span class="comment">/** Measure the actual area of all regions. Holes are not included. \n</span>
<a name="l00179"></a>00179 <span class="comment"> * This is the number of pixels of each region. \n</span>
<a name="l00180"></a>00180 <span class="comment"> * Source image is IM_GRAY/IM_USHORT type (the result of \ref imAnalyzeFindRegions). \n</span>
<a name="l00181"></a>00181 <span class="comment"> * area has size the number of regions.</span>
<a name="l00182"></a>00182 <span class="comment"> *</span>
<a name="l00183"></a>00183 <span class="comment"> * \verbatim im.AnalyzeMeasureArea(image: imImage, [region_count: number]) -&gt; area: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00184"></a>00184 <span class="comment"> * The returned table is zero indexed. </span>
<a name="l00185"></a>00185 <span class="comment"> * \ingroup analyze */</span>
<a name="l00186"></a>00186 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#ga0acd97cef006f67d8144e33aea306673">imAnalyzeMeasureArea</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span>* area, <span class="keywordtype">int</span> region_count);
<a name="l00187"></a>00187 <span class="comment"></span>
<a name="l00188"></a>00188 <span class="comment">/** Measure the polygonal area limited by the perimeter line of all regions. Holes are not included. \n</span>
<a name="l00189"></a>00189 <span class="comment"> * Notice that some regions may have polygonal area zero. \n</span>
<a name="l00190"></a>00190 <span class="comment"> * Source image is IM_GRAY/IM_USHORT type (the result of \ref imAnalyzeFindRegions). \n</span>
<a name="l00191"></a>00191 <span class="comment"> * perimarea has size the number of regions.</span>
<a name="l00192"></a>00192 <span class="comment"> *</span>
<a name="l00193"></a>00193 <span class="comment"> * \verbatim im.AnalyzeMeasurePerimArea(image: imImage, [region_count: number]) -&gt; perimarea: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00194"></a>00194 <span class="comment"> * The returned table is zero indexed. </span>
<a name="l00195"></a>00195 <span class="comment"> * \ingroup analyze */</span>
<a name="l00196"></a>00196 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#gad90f7d0f914b27be24ad88091ff50975">imAnalyzeMeasurePerimArea</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span>* perimarea);
<a name="l00197"></a>00197 <span class="comment"></span>
<a name="l00198"></a>00198 <span class="comment">/** Calculate the centroid position of all regions. Holes are not included. \n</span>
<a name="l00199"></a>00199 <span class="comment"> * Source image is IM_GRAY/IM_USHORT type (the result of \ref imAnalyzeFindRegions). \n</span>
<a name="l00200"></a>00200 <span class="comment"> * area, cx and cy have size the number of regions. If area is NULL will be internally calculated.</span>
<a name="l00201"></a>00201 <span class="comment"> *</span>
<a name="l00202"></a>00202 <span class="comment"> * \verbatim im.AnalyzeMeasureCentroid(image: imImage, [area: table of numbers], [region_count: number]) -&gt; cx: table of numbers, cy: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00203"></a>00203 <span class="comment"> * The returned tables are zero indexed. </span>
<a name="l00204"></a>00204 <span class="comment"> * \ingroup analyze */</span>
<a name="l00205"></a>00205 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#ga589b28294679b20ac668789152be96ae">imAnalyzeMeasureCentroid</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keyword">const</span> <span class="keywordtype">int</span>* area, <span class="keywordtype">int</span> region_count, <span class="keywordtype">float</span>* cx, <span class="keywordtype">float</span>* cy);
<a name="l00206"></a>00206 <span class="comment"></span>
<a name="l00207"></a>00207 <span class="comment">/** Calculate the principal major axis slope of all regions. \n</span>
<a name="l00208"></a>00208 <span class="comment"> * Source image is IM_GRAY/IM_USHORT type (the result of \ref imAnalyzeFindRegions). \n</span>
<a name="l00209"></a>00209 <span class="comment"> * data has size the number of regions. If area or centroid are NULL will be internally calculated. \n</span>
<a name="l00210"></a>00210 <span class="comment"> * Principal (major and minor) axes are defined to be those axes that pass through the</span>
<a name="l00211"></a>00211 <span class="comment"> * centroid, about which the moment of inertia of the region is, respectively maximal or minimal.</span>
<a name="l00212"></a>00212 <span class="comment"> * Partially using OpenMP when enabled.</span>
<a name="l00213"></a>00213 <span class="comment"> *</span>
<a name="l00214"></a>00214 <span class="comment"> * \verbatim im.AnalyzeMeasurePrincipalAxis(image: imImage, [area: table of numbers], [cx: table of numbers], [cy: table of numbers], [region_count: number]) </span>
<a name="l00215"></a>00215 <span class="comment">                              -&gt; major_slope: table of numbers, major_length: table of numbers, minor_slope: table of numbers, minor_length: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00216"></a>00216 <span class="comment"> * The returned tables are zero indexed. </span>
<a name="l00217"></a>00217 <span class="comment"> * \ingroup analyze */</span>
<a name="l00218"></a>00218 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#ga5f79c765e46e006d3e5ff8cce618d12d">imAnalyzeMeasurePrincipalAxis</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keyword">const</span> <span class="keywordtype">int</span>* area, <span class="keyword">const</span> <span class="keywordtype">float</span>* cx, <span class="keyword">const</span> <span class="keywordtype">float</span>* cy, 
<a name="l00219"></a>00219                                    <span class="keyword">const</span> <span class="keywordtype">int</span> region_count, <span class="keywordtype">float</span>* major_slope, <span class="keywordtype">float</span>* major_length, 
<a name="l00220"></a>00220                                                            <span class="keywordtype">float</span>* minor_slope, <span class="keywordtype">float</span>* minor_length);
<a name="l00221"></a>00221 <span class="comment"></span>
<a name="l00222"></a>00222 <span class="comment">/** Measure the number and area of holes of all regions. \n</span>
<a name="l00223"></a>00223 <span class="comment"> * Source image is IM_GRAY/IM_USHORT type (the result of \ref imAnalyzeFindRegions). \n</span>
<a name="l00224"></a>00224 <span class="comment"> * area and perim has size the number of regions, if some is NULL it will be not calculated.</span>
<a name="l00225"></a>00225 <span class="comment"> * Not using OpenMP when enabled.</span>
<a name="l00226"></a>00226 <span class="comment"> *</span>
<a name="l00227"></a>00227 <span class="comment"> * \verbatim im.AnalyzeMeasureHoles(image: imImage, connect: number, [region_count: number]) -&gt; holes_count: number, area: table of numbers, perim: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00228"></a>00228 <span class="comment"> * The returned tables are zero indexed. </span>
<a name="l00229"></a>00229 <span class="comment"> * \ingroup analyze */</span>
<a name="l00230"></a>00230 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#ga0066735798ac6889baa2774b20174188">imAnalyzeMeasureHoles</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> connect, <span class="keywordtype">int</span> *holes_count, <span class="keywordtype">int</span>* area, <span class="keywordtype">float</span>* perim);
<a name="l00231"></a>00231 <span class="comment"></span>
<a name="l00232"></a>00232 <span class="comment">/** Measure the total perimeter of all regions (external and internal). \n</span>
<a name="l00233"></a>00233 <span class="comment"> * Source image is IM_GRAY/IM_USHORT type (the result of imAnalyzeFindRegions). \n</span>
<a name="l00234"></a>00234 <span class="comment"> * It uses a half-pixel inter distance for 8 neighboors in a perimeter of a 4 connected region. \n</span>
<a name="l00235"></a>00235 <span class="comment"> * This function can also be used to measure line lenght. \n</span>
<a name="l00236"></a>00236 <span class="comment"> * perim has size the number of regions.</span>
<a name="l00237"></a>00237 <span class="comment"> *</span>
<a name="l00238"></a>00238 <span class="comment"> * \verbatim im.AnalyzeMeasurePerimeter(image: imImage) -&gt; perim: table of numbers [in Lua 5] \endverbatim</span>
<a name="l00239"></a>00239 <span class="comment"> * \ingroup analyze */</span>
<a name="l00240"></a>00240 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#gaafaea1cb5f740b365f9cb4ecb9fef370">imAnalyzeMeasurePerimeter</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span>* perim, <span class="keywordtype">int</span> region_count);
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">/** Isolates the perimeter line of gray integer images. Background is defined as being black (0). \n</span>
<a name="l00243"></a>00243 <span class="comment"> * It just checks if at least one of the 4 connected neighboors is non zero. Image borders are extended with zeros.</span>
<a name="l00244"></a>00244 <span class="comment"> *</span>
<a name="l00245"></a>00245 <span class="comment"> * \verbatim im.ProcessPerimeterLine(src_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00246"></a>00246 <span class="comment"> * \verbatim im.ProcessPerimeterLineNew(image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00247"></a>00247 <span class="comment"> * \ingroup analyze */</span>
<a name="l00248"></a>00248 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#gaffabe66b1a352e9ac93238981e6c1f31">imProcessPerimeterLine</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00249"></a>00249 <span class="comment"></span>
<a name="l00250"></a>00250 <span class="comment">/** Eliminates regions that have area size outside or inside the given interval. \n</span>
<a name="l00251"></a>00251 <span class="comment"> * Source and destiny are a binary images. Regions can be 4 connected or 8 connected. \n</span>
<a name="l00252"></a>00252 <span class="comment"> * Can be done in-place. end_size can be zero to indicate no upper limit or an area with width*height size. \n</span>
<a name="l00253"></a>00253 <span class="comment"> * When searching inside the region the limits are inclusive (&lt;= size &gt;=), when searching outside the limits are exclusive (&gt; size &lt;).</span>
<a name="l00254"></a>00254 <span class="comment"> *</span>
<a name="l00255"></a>00255 <span class="comment"> * \verbatim im.ProcessRemoveByArea(src_image: imImage, dst_image: imImage, connect: number, start_size: number, end_size: number, inside: boolean) [in Lua 5] \endverbatim</span>
<a name="l00256"></a>00256 <span class="comment"> * \verbatim im.ProcessRemoveByAreaNew(image: imImage, connect: number, start_size: number, end_size: number, inside: boolean) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00257"></a>00257 <span class="comment"> * \ingroup analyze */</span>
<a name="l00258"></a>00258 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#ga165dc2e747fa1b7ccdb7af190132606d">imProcessRemoveByArea</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> connect, <span class="keywordtype">int</span> start_size, <span class="keywordtype">int</span> end_size, <span class="keywordtype">int</span> inside);
<a name="l00259"></a>00259 <span class="comment"></span>
<a name="l00260"></a>00260 <span class="comment">/** Fill holes inside white regions. \n</span>
<a name="l00261"></a>00261 <span class="comment"> * Source and destiny are a binary images. Regions can be 4 connected or 8 connected. \n</span>
<a name="l00262"></a>00262 <span class="comment"> * Can be done in-place. </span>
<a name="l00263"></a>00263 <span class="comment"> *</span>
<a name="l00264"></a>00264 <span class="comment"> * \verbatim im.ProcessFillHoles(src_image: imImage, dst_image: imImage, connect: number) [in Lua 5] \endverbatim</span>
<a name="l00265"></a>00265 <span class="comment"> * \verbatim im.ProcessFillHolesNew(image: imImage, connect: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00266"></a>00266 <span class="comment"> * \ingroup analyze */</span>
<a name="l00267"></a>00267 <span class="keywordtype">void</span> <a class="code" href="group__analyze.html#gaf8949c2ac8e43bc8b255e4de025f2a0a">imProcessFillHoles</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> connect);
<a name="l00268"></a>00268 
<a name="l00269"></a>00269 
<a name="l00270"></a>00270 <span class="preprocessor">#if defined(__cplusplus)</span>
<a name="l00271"></a>00271 <span class="preprocessor"></span>}
<a name="l00272"></a>00272 <span class="preprocessor">#endif</span>
<a name="l00273"></a>00273 <span class="preprocessor"></span>
<a name="l00274"></a>00274 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:06 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
