<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: Convolution Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Convolution Operations<br/>
<small>
[<a class="el" href="group__process.html">Image Processing</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Convolution Operations:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__convolve.png" border="0" alt="" usemap="#group____convolve"/>
<map name="group____convolve" id="group____convolve">
<area shape="rect" id="node1" href="group__kernel.html" title="Kernel Generators" alt="" coords="448,5,603,37"/><area shape="rect" id="node2" href="group__process.html" title="Image Processing" alt="" coords="5,5,160,37"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__kernel.html">Kernel Generators</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga1d8ee207c12756d5fbe07788baaa6365">imProcessConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, const <a class="el" href="struct__imImage.html">imImage</a> *kernel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#gad689cbf68db9f4682b936529d47ae07c">imProcessConvolveSep</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, const <a class="el" href="struct__imImage.html">imImage</a> *kernel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga9a7d71e9159c343f71734dd65cd48edd">imProcessConvolveDual</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, const <a class="el" href="struct__imImage.html">imImage</a> *kernel1, const <a class="el" href="struct__imImage.html">imImage</a> *kernel2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#gaf402b18b9fc208bd15db2fb1ceeb9882">imProcessConvolveRep</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, const <a class="el" href="struct__imImage.html">imImage</a> *kernel, int count)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga28753d2da2679f7cdcb76739ce40324c">imProcessCompassConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, <a class="el" href="struct__imImage.html">imImage</a> *kernel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga335626fc1faa3ec97c1d8a63eb296af8">imProcessRotateKernel</a> (<a class="el" href="struct__imImage.html">imImage</a> *kernel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga3d8a84604092045ca709c9b17c7f0d6f">imProcessDiffOfGaussianConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float stddev1, float stddev2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga238e2bc52ac3368335216fe8a6d96dd2">imProcessLapOfGaussianConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float stddev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga1262ed8bd551600eaf6736148b4bc45a">imProcessMeanConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int kernel_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga8d655eb654ec4f4191c5051d8a5297ca">imProcessGaussianConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float stddev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga1bd04482d1b5a8726bd87b2c2ac17d22">imProcessBarlettConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int kernel_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga6b8c33d2724f8f1130eecab0a6601725">imProcessSobelConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#gaf4e781cc40c43b4e306343b5a880e72d">imProcessPrewittConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#gab47e9c62740eaeb7f10b32dee1cfeed2">imProcessSplineEdgeConvolve</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga1b0a9c1a7dff8c12f9dba3292ee8316f">imProcessZeroCrossing</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga8688b3e6ca6d1c804c05a4c004770097">imProcessCanny</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float stddev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#gae8c27f7d96992767bf3db1bc204c0ba7">imGaussianStdDev2KernelSize</a> (float stddev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#gac81147c4aa30943a0790011ff0c3e754">imGaussianKernelSize2StdDev</a> (int kernel_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#gaa09e8286967c765961b1391c82cf9e77">imProcessUnsharp</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float stddev, float amount, float threshold)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga281ae90915b9491d53373a7047b42c43">imProcessSharp</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float amount, float threshold)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__convolve.html#ga0c5837e4a24481cd0782ad326ff12640">imProcessSharpKernel</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, const <a class="el" href="struct__imImage.html">imImage</a> *kernel, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float amount, float threshold)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b></b></dt><dd>See <a class="el" href="im__process__loc_8h.html">im_process_loc.h</a> </dd></dl>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga1d8ee207c12756d5fbe07788baaa6365"></a><!-- doxytag: member="im_process_loc.h::imProcessConvolve" ref="ga1d8ee207c12756d5fbe07788baaa6365" args="(const imImage *src_image, imImage *dst_image, const imImage *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Base Convolution with a kernel. <br/>
 Kernel can be IM_INT or IM_FLOAT, but always IM_GRAY. Use kernel size odd for better results. <br/>
 Supports all data types. The border is mirrored. <br/>
 Returns zero if the counter aborted. Most of the convolutions use this function.<br/>
 If the kernel image attribute "Description" exists it is used by the counter.</p>
<div class="fragment"><pre class="fragment">im.ProcessConvolve(src_image: imImage, dst_image: imImage, kernel: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessConvolveNew(image: imImage, kernel: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gad689cbf68db9f4682b936529d47ae07c"></a><!-- doxytag: member="im_process_loc.h::imProcessConvolveSep" ref="gad689cbf68db9f4682b936529d47ae07c" args="(const imImage *src_image, imImage *dst_image, const imImage *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessConvolveSep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Base convolution when the kernel is separable. Only the first line and the first column will be used. <br/>
 Returns zero if the counter aborted.<br/>
 If the kernel image attribute "Description" exists it is used by the counter.</p>
<div class="fragment"><pre class="fragment">im.ProcessConvolveSep(src_image: imImage, dst_image: imImage, kernel: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessConvolveSepNew(image: imImage, kernel: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga9a7d71e9159c343f71734dd65cd48edd"></a><!-- doxytag: member="im_process_loc.h::imProcessConvolveDual" ref="ga9a7d71e9159c343f71734dd65cd48edd" args="(const imImage *src_image, imImage *dst_image, const imImage *kernel1, const imImage *kernel2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessConvolveDual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Base Convolution with two kernels. The result is the magnitude of the result of each convolution. <br/>
 Kernel can be IM_INT or IM_FLOAT, but always IM_GRAY. Use kernel size odd for better results. <br/>
 Supports all data types. The border is mirrored. <br/>
 Returns zero if the counter aborted. Most of the convolutions use this function.<br/>
 If the kernel image attribute "Description" exists it is used by the counter.</p>
<div class="fragment"><pre class="fragment">im.ProcessConvolveDual(src_image: imImage, dst_image: imImage, kernel1, kernel2: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessConvolveDualNew(image: imImage, kernel1, kernel2: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gaf402b18b9fc208bd15db2fb1ceeb9882"></a><!-- doxytag: member="im_process_loc.h::imProcessConvolveRep" ref="gaf402b18b9fc208bd15db2fb1ceeb9882" args="(const imImage *src_image, imImage *dst_image, const imImage *kernel, int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessConvolveRep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Repeats the convolution a number of times. <br/>
 Returns zero if the counter aborted.<br/>
 If the kernel image attribute "Description" exists it is used by the counter.</p>
<div class="fragment"><pre class="fragment">im.ProcessConvolveRep(src_image: imImage, dst_image: imImage, kernel: imImage, count: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessConvolveRepNew(image: imImage, kernel: imImage, count: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga28753d2da2679f7cdcb76739ce40324c"></a><!-- doxytag: member="im_process_loc.h::imProcessCompassConvolve" ref="ga28753d2da2679f7cdcb76739ce40324c" args="(const imImage *src_image, imImage *dst_image, imImage *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessCompassConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convolve with a kernel rotating it 8 times and getting the absolute maximum value. <br/>
 Kernel must be square. <br/>
 The rotation is implemented only for kernel sizes 3x3, 5x5 and 7x7. <br/>
 Supports all data types except IM_CFLOAT. Returns zero if the counter aborted.<br/>
 If the kernel image attribute "Description" exists it is used by the counter.</p>
<div class="fragment"><pre class="fragment">im.ProcessCompassConvolve(src_image: imImage, dst_image: imImage, kernel: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessCompassConvolveNew(image: imImage, kernel: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga335626fc1faa3ec97c1d8a63eb296af8"></a><!-- doxytag: member="im_process_loc.h::imProcessRotateKernel" ref="ga335626fc1faa3ec97c1d8a63eb296af8" args="(imImage *kernel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessRotateKernel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Utility function to rotate a kernel one time.</p>
<div class="fragment"><pre class="fragment">im.ProcessRotateKernel(kernel: imImage) [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga3d8a84604092045ca709c9b17c7f0d6f"></a><!-- doxytag: member="im_process_loc.h::imProcessDiffOfGaussianConvolve" ref="ga3d8a84604092045ca709c9b17c7f0d6f" args="(const imImage *src_image, imImage *dst_image, float stddev1, float stddev2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessDiffOfGaussianConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stddev1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stddev2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Difference(Gaussian1, Gaussian2). <br/>
 Supports all data types, but if source is IM_BYTE or IM_USHORT destiny image must be of type IM_INT.</p>
<div class="fragment"><pre class="fragment">im.ProcessDiffOfGaussianConvolve(src_image: imImage, dst_image: imImage, stddev1: number, stddev2: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessDiffOfGaussianConvolveNew(image: imImage, stddev1: number, stddev2: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga238e2bc52ac3368335216fe8a6d96dd2"></a><!-- doxytag: member="im_process_loc.h::imProcessLapOfGaussianConvolve" ref="ga238e2bc52ac3368335216fe8a6d96dd2" args="(const imImage *src_image, imImage *dst_image, float stddev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessLapOfGaussianConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stddev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convolution with a laplacian of a gaussian kernel. <br/>
 Supports all data types, but if source is IM_BYTE or IM_USHORT destiny image must be of type IM_INT.</p>
<div class="fragment"><pre class="fragment">im.ProcessLapOfGaussianConvolve(src_image: imImage, dst_image: imImage, stddev: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessLapOfGaussianConvolveNew(image: imImage, stddev: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga1262ed8bd551600eaf6736148b4bc45a"></a><!-- doxytag: member="im_process_loc.h::imProcessMeanConvolve" ref="ga1262ed8bd551600eaf6736148b4bc45a" args="(const imImage *src_image, imImage *dst_image, int kernel_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessMeanConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kernel_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convolution with a kernel full of "1"s inside a circle. <br/>
 Supports all data types.</p>
<div class="fragment"><pre class="fragment">im.ProcessMeanConvolve(src_image: imImage, dst_image: imImage, kernel_size: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMeanConvolveNew(image: imImage, kernel_size: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga8d655eb654ec4f4191c5051d8a5297ca"></a><!-- doxytag: member="im_process_loc.h::imProcessGaussianConvolve" ref="ga8d655eb654ec4f4191c5051d8a5297ca" args="(const imImage *src_image, imImage *dst_image, float stddev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessGaussianConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stddev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convolution with a float gaussian kernel. <br/>
 If sdtdev is negative its magnitude will be used as the kernel size. <br/>
 Supports all data types.</p>
<div class="fragment"><pre class="fragment">im.ProcessGaussianConvolve(src_image: imImage, dst_image: imImage, stddev: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessGaussianConvolveNew(image: imImage, stddev: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga1bd04482d1b5a8726bd87b2c2ac17d22"></a><!-- doxytag: member="im_process_loc.h::imProcessBarlettConvolve" ref="ga1bd04482d1b5a8726bd87b2c2ac17d22" args="(const imImage *src_image, imImage *dst_image, int kernel_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessBarlettConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kernel_size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convolution with a barlett kernel. <br/>
 Supports all data types.</p>
<div class="fragment"><pre class="fragment">im.ProcessBarlettConvolve(src_image: imImage, dst_image: imImage, kernel_size: number) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessBarlettConvolveNew(image: imImage, kernel_size: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga6b8c33d2724f8f1130eecab0a6601725"></a><!-- doxytag: member="im_process_loc.h::imProcessSobelConvolve" ref="ga6b8c33d2724f8f1130eecab0a6601725" args="(const imImage *src_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessSobelConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Magnitude of the sobel convolution. <br/>
 Supports all data types.</p>
<div class="fragment"><pre class="fragment">im.ProcessSobelConvolve(src_image: imImage, dst_image: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessSobelConvolveNew(image: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gaf4e781cc40c43b4e306343b5a880e72d"></a><!-- doxytag: member="im_process_loc.h::imProcessPrewittConvolve" ref="gaf4e781cc40c43b4e306343b5a880e72d" args="(const imImage *src_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessPrewittConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Magnitude of the prewitt convolution. <br/>
 Supports all data types.</p>
<div class="fragment"><pre class="fragment">im.ProcessPrewittConvolve(src_image: imImage, dst_image: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessPrewittConvolveNew(image: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gab47e9c62740eaeb7f10b32dee1cfeed2"></a><!-- doxytag: member="im_process_loc.h::imProcessSplineEdgeConvolve" ref="gab47e9c62740eaeb7f10b32dee1cfeed2" args="(const imImage *src_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessSplineEdgeConvolve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Spline edge dectection. <br/>
 Supports all data types.</p>
<div class="fragment"><pre class="fragment">im.ProcessSplineEdgeConvolve(src_image: imImage, dst_image: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessSplineEdgeConvolveNew(image: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga1b0a9c1a7dff8c12f9dba3292ee8316f"></a><!-- doxytag: member="im_process_loc.h::imProcessZeroCrossing" ref="ga1b0a9c1a7dff8c12f9dba3292ee8316f" args="(const imImage *src_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessZeroCrossing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the zero crossings of IM_INT and IM_FLOAT images. Crossings are marked with non zero values indicating the intensity of the edge. It is usually used after a second derivative, laplace. <br/>
 Extracted from XITE, Copyright 1991, Blab, UiO <br/>
 <a href="http://www.ifi.uio.no/~blab/Software/Xite/">http://www.ifi.uio.no/~blab/Software/Xite/</a></p>
<div class="fragment"><pre class="fragment">im.ProcessZeroCrossing(src_image: imImage, dst_image: imImage) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessZeroCrossingNew(image: imImage) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga8688b3e6ca6d1c804c05a4c004770097"></a><!-- doxytag: member="im_process_loc.h::imProcessCanny" ref="ga8688b3e6ca6d1c804c05a4c004770097" args="(const imImage *src_image, imImage *dst_image, float stddev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessCanny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stddev</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>First part of the Canny edge detector. Includes the gaussian filtering and the nonmax suppression. <br/>
 After using this you could apply a Hysteresis Threshold, see <a class="el" href="group__threshold.html#ga7ada706234fb5e51cff920c8d491303f">imProcessHysteresisThreshold</a>. <br/>
 Image must be IM_BYTE/IM_GRAY. <br/>
 Implementation from the book: </p>
<div class="fragment"><pre class="fragment">
    J. R. Parker
    "Algoritms for Image Processing and Computer Vision"
    WILEY
 </pre></div><div class="fragment"><pre class="fragment">im.ProcessCanny(src_image: imImage, dst_image: imImage, stddev: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessCannyNew(image: imImage, stddev: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gae8c27f7d96992767bf3db1bc204c0ba7"></a><!-- doxytag: member="im_process_loc.h::imGaussianStdDev2KernelSize" ref="gae8c27f7d96992767bf3db1bc204c0ba7" args="(float stddev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imGaussianStdDev2KernelSize </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stddev</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the kernel size given the standard deviation. <br/>
 If sdtdev is negative its magnitude will be used as the kernel size.</p>
<div class="fragment"><pre class="fragment">im.GaussianStdDev2KernelSize(stddev: number) -&gt; kernel_size: number [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gac81147c4aa30943a0790011ff0c3e754"></a><!-- doxytag: member="im_process_loc.h::imGaussianKernelSize2StdDev" ref="gac81147c4aa30943a0790011ff0c3e754" args="(int kernel_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float imGaussianKernelSize2StdDev </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>kernel_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the standard deviation given the kernel size.</p>
<div class="fragment"><pre class="fragment">im.GaussianKernelSize2StdDev(kernel_size: number) -&gt; stddev: number [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gaa09e8286967c765961b1391c82cf9e77"></a><!-- doxytag: member="im_process_loc.h::imProcessUnsharp" ref="gaa09e8286967c765961b1391c82cf9e77" args="(const imImage *src_image, imImage *dst_image, float stddev, float amount, float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessUnsharp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stddev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Edge enhancement using Unsharp mask. stddev control the gaussian filter, amount controls how much the edges will enhance the image (0&lt;amount&lt;1), and threshold controls which edges will be considered, it compares to twice of the absolute size of the edge. Although very similar to <a class="el" href="group__convolve.html#ga281ae90915b9491d53373a7047b42c43">imProcessSharp</a>, produces better results.</p>
<div class="fragment"><pre class="fragment">im.ProcessUnsharp(src_image: imImage, dst_image: imImage, stddev: number, amount: number, threshold: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessUnsharpNew(image: imImage, stddev: number, amount: number, threshold: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga281ae90915b9491d53373a7047b42c43"></a><!-- doxytag: member="im_process_loc.h::imProcessSharp" ref="ga281ae90915b9491d53373a7047b42c43" args="(const imImage *src_image, imImage *dst_image, float amount, float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessSharp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Edge enhancement using Laplacian8 mask. amount controls how much the edges will enhance the image (0&lt;amount&lt;1), and threshold controls which edges will be considered, it compares to twice of the absolute size of the edge.</p>
<div class="fragment"><pre class="fragment">im.ProcessSharp(src_image: imImage, dst_image: imImage, amount: number, threshold: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessSharpNew(image: imImage, amount: number, threshold: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga0c5837e4a24481cd0782ad326ff12640"></a><!-- doxytag: member="im_process_loc.h::imProcessSharpKernel" ref="ga0c5837e4a24481cd0782ad326ff12640" args="(const imImage *src_image, const imImage *kernel, imImage *dst_image, float amount, float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessSharpKernel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>amount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Edge enhancement using a given kernel. If kernel has all positive values, then the unsharp technique is used, else sharp is used. amount controls how much the edges will enhance the image (0&lt;amount&lt;1), and threshold controls which edges will be considered, it compares to twice of the absolute size of the edge.</p>
<div class="fragment"><pre class="fragment">im.ProcessSharp(src_image: imImage, dst_image: imImage, amount: number, threshold: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessSharpNew(image: imImage, amount: number, threshold: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:07 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
