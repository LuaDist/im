<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: Point Based Custom Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Point Based Custom Operations<br/>
<small>
[<a class="el" href="group__process.html">Image Processing</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Point Based Custom Operations:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__point.png" border="0" alt="" usemap="#group____point"/>
<map name="group____point" id="group____point">
<area shape="rect" id="node1" href="group__process.html" title="Image Processing" alt="" coords="5,5,160,37"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#ga314df33ff66f025977b8797282d0bf60">imUnaryPointOpFunc</a> )(float src_value, float *dst_value, float *params, void *userdata, int x, int y, int d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#ga7d46d0484850c65c37ad595967921497">imUnaryPointColorOpFunc</a> )(const float *src_value, float *dst_value, float *params, void *userdata, int x, int y)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#gae69c44788e933d5ae7db7c77b7816da6">imMultiPointOpFunc</a> )(const float *src_value, float *dst_value, float *params, void *userdata, int x, int y, int d)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#ga11862724e52576101dcba362756677af">imMultiPointColorOpFunc</a> )(float *src_value, float *dst_value, float *params, void *userdata, int x, int y)</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#gaf8c27766f05fc2a490c27808b05f0dcf">imProcessUnaryPointOp</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, <a class="el" href="group__point.html#ga314df33ff66f025977b8797282d0bf60">imUnaryPointOpFunc</a> func, float *params, void *userdata, const char *op_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#ga3c4c9edea678275e65425487e3703fb3">imProcessUnaryPointColorOp</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, <a class="el" href="group__point.html#ga7d46d0484850c65c37ad595967921497">imUnaryPointColorOpFunc</a> func, float *params, void *userdata, const char *op_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#gaa096618b3bb044398fb95c550f53b540">imProcessMultiPointOp</a> (const <a class="el" href="struct__imImage.html">imImage</a> **src_image, int src_count, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, <a class="el" href="group__point.html#gae69c44788e933d5ae7db7c77b7816da6">imMultiPointOpFunc</a> func, float *params, void *userdata, const char *op_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__point.html#ga2c6b5718a76ce2b10e8ba9da9b63c270">imProcessMultiPointColorOp</a> (const <a class="el" href="struct__imImage.html">imImage</a> **src_image, int src_count, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, <a class="el" href="group__point.html#ga11862724e52576101dcba362756677af">imMultiPointColorOpFunc</a> func, float *params, void *userdata, const char *op_name)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b></b></dt><dd>See <a class="el" href="im__process__pnt_8h.html">im_process_pnt.h</a> </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga314df33ff66f025977b8797282d0bf60"></a><!-- doxytag: member="im_process_pnt.h::imUnaryPointOpFunc" ref="ga314df33ff66f025977b8797282d0bf60" args=")(float src_value, float *dst_value, float *params, void *userdata, int x, int y, int d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__point.html#ga314df33ff66f025977b8797282d0bf60">imUnaryPointOpFunc</a>)(float src_value, float *dst_value, float *params, void *userdata, int x, int y, int d)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Custom unary point funtion. </p>
<div class="fragment"><pre class="fragment">func(src_value: number, params1, param2, ..., x: number, y: number, d: number) -&gt; dst_value: number  [in Lua 5] </pre></div><p> In Lua, the params table is unpacked. And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact. </p>

</div>
</div>
<a class="anchor" id="ga7d46d0484850c65c37ad595967921497"></a><!-- doxytag: member="im_process_pnt.h::imUnaryPointColorOpFunc" ref="ga7d46d0484850c65c37ad595967921497" args=")(const float *src_value, float *dst_value, float *params, void *userdata, int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__point.html#ga7d46d0484850c65c37ad595967921497">imUnaryPointColorOpFunc</a>)(const float *src_value, float *dst_value, float *params, void *userdata, int x, int y)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Custom unary point color funtion. </p>
<div class="fragment"><pre class="fragment">func(src_value_plane0: number, src_value_plane1: number, ... , params1, param2, ..., x: number, y: number) -&gt; dst_value_plane0: number, dst_value_plane1: number, ...  [in Lua 5] </pre></div><p> In Lua, the params table is unpacked. Also each color plane is passed as a separe value, instead of inside an array. And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact. </p>

</div>
</div>
<a class="anchor" id="gae69c44788e933d5ae7db7c77b7816da6"></a><!-- doxytag: member="im_process_pnt.h::imMultiPointOpFunc" ref="gae69c44788e933d5ae7db7c77b7816da6" args=")(const float *src_value, float *dst_value, float *params, void *userdata, int x, int y, int d)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__point.html#gae69c44788e933d5ae7db7c77b7816da6">imMultiPointOpFunc</a>)(const float *src_value, float *dst_value, float *params, void *userdata, int x, int y, int d)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Custom multiple point funtion. </p>
<div class="fragment"><pre class="fragment">func(src_value1: number, src_value2: number, ... , params1, param2, ..., x: number, y: number, d: number) -&gt; dst_value: number  [in Lua 5] </pre></div><p> In Lua, the source images data and the params table are unpacked. And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact. </p>

</div>
</div>
<a class="anchor" id="ga11862724e52576101dcba362756677af"></a><!-- doxytag: member="im_process_pnt.h::imMultiPointColorOpFunc" ref="ga11862724e52576101dcba362756677af" args=")(float *src_value, float *dst_value, float *params, void *userdata, int x, int y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* <a class="el" href="group__point.html#ga11862724e52576101dcba362756677af">imMultiPointColorOpFunc</a>)(float *src_value, float *dst_value, float *params, void *userdata, int x, int y)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Custom multiple point color funtion. </p>
<div class="fragment"><pre class="fragment">func(src_value1_plane0: number, src_value1_plane1: number, ..., src_value2_plane0: number, src_value2_plane1: number, ... , params1, param2, ..., x: number, y: number) -&gt; dst_value_plane0: number, dst_value_plane1: number, ...  [in Lua 5] </pre></div><p> In Lua, the source images data and the params table are unpacked. Also each color plane is passed as a separe value, instead of inside an array. And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf8c27766f05fc2a490c27808b05f0dcf"></a><!-- doxytag: member="im_process_pnt.h::imProcessUnaryPointOp" ref="gaf8c27766f05fc2a490c27808b05f0dcf" args="(const imImage *src_image, imImage *dst_image, imUnaryPointOpFunc func, float *params, void *userdata, const char *op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessUnaryPointOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__point.html#ga314df33ff66f025977b8797282d0bf60">imUnaryPointOpFunc</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply an unary point operation using a custom function. One pixel from the source affects the same pixel on destiny. <br/>
 Can be done in-place, images must match size and depth. Data type can be different, but IM_CFLOAT is not supported. <br/>
 op_name is used only by the counter and can be NULL. Data will be set only if cond is true. Returns zero if the counter aborted.</p>
<div class="fragment"><pre class="fragment">im.ProcessUnaryPointOp(src_image: imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessUnaryPointOpNew(image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div><p> In Lua, the params table is passed to the function by using the Lua stack, so its table can contain any type of objects, but they all must be unnamed. </p>

</div>
</div>
<a class="anchor" id="ga3c4c9edea678275e65425487e3703fb3"></a><!-- doxytag: member="im_process_pnt.h::imProcessUnaryPointColorOp" ref="ga3c4c9edea678275e65425487e3703fb3" args="(const imImage *src_image, imImage *dst_image, imUnaryPointColorOpFunc func, float *params, void *userdata, const char *op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessUnaryPointColorOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__point.html#ga7d46d0484850c65c37ad595967921497">imUnaryPointColorOpFunc</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply an unary point color operation using a custom function. One pixel from the source affects the same pixel on destiny. <br/>
 Can be done in-place, images must match size, depth can be different. Data type can be different, but IM_CFLOAT is not supported. <br/>
 op_name is used only by the counter and can be NULL. Data will be set only if cond is true. Returns zero if the counter aborted.</p>
<div class="fragment"><pre class="fragment">im.ProcessUnaryPointColorOp(src_image: imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessUnaryPointColorOpNew(image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div><p> In Lua, the params table is passed to the function by using the Lua stack, so its table can contain any type of objects, but they all must be unnamed. </p>

</div>
</div>
<a class="anchor" id="gaa096618b3bb044398fb95c550f53b540"></a><!-- doxytag: member="im_process_pnt.h::imProcessMultiPointOp" ref="gaa096618b3bb044398fb95c550f53b540" args="(const imImage **src_image, int src_count, imImage *dst_image, imMultiPointOpFunc func, float *params, void *userdata, const char *op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessMultiPointOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> **&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__point.html#gae69c44788e933d5ae7db7c77b7816da6">imMultiPointOpFunc</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply an multiple point operation using a custom function. One pixel from each source affects the same pixel on destiny. <br/>
 All source images must match in size, depth and data type. Can be done in-place, source and destiny must match size and depth. Data type can be different between sources and destiny, but IM_CFLOAT is not supported. <br/>
 op_name is used only by the counter and can be NULL. Data will be set only if cond is true. Returns zero if the counter aborted.</p>
<div class="fragment"><pre class="fragment">im.ProcessMultiPointOp(src_image: table of imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMultiPointOpNew(src_image: table of imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div><p> In Lua, the params table is passed to the function by using the Lua stack, so its table can contain any type of objects, but they all must be unnamed. </p>

</div>
</div>
<a class="anchor" id="ga2c6b5718a76ce2b10e8ba9da9b63c270"></a><!-- doxytag: member="im_process_pnt.h::imProcessMultiPointColorOp" ref="ga2c6b5718a76ce2b10e8ba9da9b63c270" args="(const imImage **src_image, int src_count, imImage *dst_image, imMultiPointColorOpFunc func, float *params, void *userdata, const char *op_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessMultiPointColorOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> **&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__point.html#ga11862724e52576101dcba362756677af">imMultiPointColorOpFunc</a>&nbsp;</td>
          <td class="paramname"> <em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userdata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>op_name</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply an multiple point color operation using a custom function. One pixel from each source affects the same pixel on destiny. <br/>
 All source images must match in size, depth and data type. Can be done in-place, source and destiny must match size, depth can be different. Data type can be different between sources and destiny, but IM_CFLOAT is not supported. <br/>
 op_name is used only by the counter and can be NULL. Data will be set only if cond is true. Returns zero if the counter aborted.</p>
<div class="fragment"><pre class="fragment">im.ProcessMultiPointColorOp(src_image: table of imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMultiPointColorOpNew(src_image: table of imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div><p> In Lua, the params table is passed to the function by using the Lua stack, so its table can contain any type of objects, but they all must be unnamed. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:07 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
