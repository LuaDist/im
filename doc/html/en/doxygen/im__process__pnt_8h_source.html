<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: im_process_pnt.h Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="headertitle">
<h1>im_process_pnt.h</h1>  </div>
</div>
<div class="contents">
<a href="im__process__pnt_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/** \file</span>
<a name="l00002"></a>00002 <span class="comment"> * \brief Image Processing - Point Operations</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * See Copyright Notice in im_lib.h</span>
<a name="l00005"></a>00005 <span class="comment"> */</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="preprocessor">#ifndef __IM_PROCESS_PNT_H</span>
<a name="l00008"></a>00008 <span class="preprocessor"></span><span class="preprocessor">#define __IM_PROCESS_PNT_H</span>
<a name="l00009"></a>00009 <span class="preprocessor"></span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;<a class="code" href="im__image_8h.html" title="Image Manipulation.">im_image.h</a>&quot;</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="preprocessor">#if     defined(__cplusplus)</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00014"></a>00014 <span class="preprocessor">#endif</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">/** \defgroup point Point Based Custom Operations </span>
<a name="l00017"></a>00017 <span class="comment"> * \par</span>
<a name="l00018"></a>00018 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00019"></a>00019 <span class="comment"> * \ingroup process */</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="comment"></span>
<a name="l00022"></a>00022 <span class="comment">/** Custom unary point funtion.</span>
<a name="l00023"></a>00023 <span class="comment"> * \verbatim func(src_value: number, params1, param2, ..., x: number, y: number, d: number) -&gt; dst_value: number  [in Lua 5] \endverbatim</span>
<a name="l00024"></a>00024 <span class="comment"> * In Lua, the params table is unpacked.</span>
<a name="l00025"></a>00025 <span class="comment"> * And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact.</span>
<a name="l00026"></a>00026 <span class="comment"> * \ingroup point */</span>
<a name="l00027"></a><a class="code" href="group__point.html#ga314df33ff66f025977b8797282d0bf60">00027</a> <span class="keyword">typedef</span> int (*<a class="code" href="group__point.html#ga314df33ff66f025977b8797282d0bf60">imUnaryPointOpFunc</a>)(<span class="keywordtype">float</span> src_value, <span class="keywordtype">float</span> *dst_value, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> d);
<a name="l00028"></a>00028 <span class="comment"></span>
<a name="l00029"></a>00029 <span class="comment">/** Apply an unary point operation using a custom function.</span>
<a name="l00030"></a>00030 <span class="comment"> * One pixel from the source affects the same pixel on destiny. \n</span>
<a name="l00031"></a>00031 <span class="comment"> * Can be done in-place, images must match size and depth. </span>
<a name="l00032"></a>00032 <span class="comment"> * Data type can be different, but IM_CFLOAT is not supported. \n</span>
<a name="l00033"></a>00033 <span class="comment"> * op_name is used only by the counter and can be NULL. Data will be set only if cond is true. </span>
<a name="l00034"></a>00034 <span class="comment"> * Returns zero if the counter aborted.</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> * \verbatim im.ProcessUnaryPointOp(src_image: imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00037"></a>00037 <span class="comment"> * \verbatim im.ProcessUnaryPointOpNew(image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00038"></a>00038 <span class="comment"> * In Lua, the params table is passed to the function by using the Lua stack, </span>
<a name="l00039"></a>00039 <span class="comment"> * so its table can contain any type of objects, but they all must be unnamed.</span>
<a name="l00040"></a>00040 <span class="comment"> * \ingroup point */</span>
<a name="l00041"></a>00041 <span class="keywordtype">int</span> <a class="code" href="group__point.html#gaf8c27766f05fc2a490c27808b05f0dcf">imProcessUnaryPointOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <a class="code" href="group__point.html#ga314df33ff66f025977b8797282d0bf60">imUnaryPointOpFunc</a> func, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keyword">const</span> <span class="keywordtype">char</span>* op_name);
<a name="l00042"></a>00042 <span class="comment"></span>
<a name="l00043"></a>00043 <span class="comment">/** Custom unary point color funtion.</span>
<a name="l00044"></a>00044 <span class="comment"> * \verbatim func(src_value_plane0: number, src_value_plane1: number, ... , params1, param2, ..., x: number, y: number) -&gt; dst_value_plane0: number, dst_value_plane1: number, ...  [in Lua 5] \endverbatim</span>
<a name="l00045"></a>00045 <span class="comment"> * In Lua, the params table is unpacked.</span>
<a name="l00046"></a>00046 <span class="comment"> * Also each color plane is passed as a separe value, instead of inside an array.</span>
<a name="l00047"></a>00047 <span class="comment"> * And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact.</span>
<a name="l00048"></a>00048 <span class="comment"> * \ingroup point */</span>
<a name="l00049"></a><a class="code" href="group__point.html#ga7d46d0484850c65c37ad595967921497">00049</a> <span class="keyword">typedef</span> int (*<a class="code" href="group__point.html#ga7d46d0484850c65c37ad595967921497">imUnaryPointColorOpFunc</a>)(<span class="keyword">const</span> <span class="keywordtype">float</span>* src_value, <span class="keywordtype">float</span> *dst_value, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="comment">/** Apply an unary point color operation using a custom function.</span>
<a name="l00052"></a>00052 <span class="comment"> * One pixel from the source affects the same pixel on destiny. \n</span>
<a name="l00053"></a>00053 <span class="comment"> * Can be done in-place, images must match size, depth can be different.</span>
<a name="l00054"></a>00054 <span class="comment"> * Data type can be different, but IM_CFLOAT is not supported. \n</span>
<a name="l00055"></a>00055 <span class="comment"> * op_name is used only by the counter and can be NULL. Data will be set only if cond is true. </span>
<a name="l00056"></a>00056 <span class="comment"> * Returns zero if the counter aborted.</span>
<a name="l00057"></a>00057 <span class="comment"> *</span>
<a name="l00058"></a>00058 <span class="comment"> * \verbatim im.ProcessUnaryPointColorOp(src_image: imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00059"></a>00059 <span class="comment"> * \verbatim im.ProcessUnaryPointColorOpNew(image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00060"></a>00060 <span class="comment"> * In Lua, the params table is passed to the function by using the Lua stack, </span>
<a name="l00061"></a>00061 <span class="comment"> * so its table can contain any type of objects, but they all must be unnamed.</span>
<a name="l00062"></a>00062 <span class="comment"> * \ingroup point */</span>
<a name="l00063"></a>00063 <span class="keywordtype">int</span> <a class="code" href="group__point.html#ga3c4c9edea678275e65425487e3703fb3">imProcessUnaryPointColorOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <a class="code" href="group__point.html#ga7d46d0484850c65c37ad595967921497">imUnaryPointColorOpFunc</a> func, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keyword">const</span> <span class="keywordtype">char</span>* op_name);
<a name="l00064"></a>00064 <span class="comment"></span>
<a name="l00065"></a>00065 <span class="comment">/** Custom multiple point funtion.</span>
<a name="l00066"></a>00066 <span class="comment"> * \verbatim func(src_value1: number, src_value2: number, ... , params1, param2, ..., x: number, y: number, d: number) -&gt; dst_value: number  [in Lua 5] \endverbatim</span>
<a name="l00067"></a>00067 <span class="comment"> * In Lua, the source images data and the params table are unpacked.</span>
<a name="l00068"></a>00068 <span class="comment"> * And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact.</span>
<a name="l00069"></a>00069 <span class="comment"> * \ingroup point */</span>
<a name="l00070"></a><a class="code" href="group__point.html#gae69c44788e933d5ae7db7c77b7816da6">00070</a> <span class="keyword">typedef</span> int (*<a class="code" href="group__point.html#gae69c44788e933d5ae7db7c77b7816da6">imMultiPointOpFunc</a>)(<span class="keyword">const</span> <span class="keywordtype">float</span>* src_value, <span class="keywordtype">float</span> *dst_value, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> d);
<a name="l00071"></a>00071 <span class="comment"></span>
<a name="l00072"></a>00072 <span class="comment">/** Apply an multiple point operation using a custom function.</span>
<a name="l00073"></a>00073 <span class="comment"> * One pixel from each source affects the same pixel on destiny. \n</span>
<a name="l00074"></a>00074 <span class="comment"> * All source images must match in size, depth and data type.</span>
<a name="l00075"></a>00075 <span class="comment"> * Can be done in-place, source and destiny must match size and depth.</span>
<a name="l00076"></a>00076 <span class="comment"> * Data type can be different between sources and destiny, but IM_CFLOAT is not supported. \n</span>
<a name="l00077"></a>00077 <span class="comment"> * op_name is used only by the counter and can be NULL. Data will be set only if cond is true. </span>
<a name="l00078"></a>00078 <span class="comment"> * Returns zero if the counter aborted.</span>
<a name="l00079"></a>00079 <span class="comment"> *</span>
<a name="l00080"></a>00080 <span class="comment"> * \verbatim im.ProcessMultiPointOp(src_image: table of imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00081"></a>00081 <span class="comment"> * \verbatim im.ProcessMultiPointOpNew(src_image: table of imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00082"></a>00082 <span class="comment"> * In Lua, the params table is passed to the function by using the Lua stack, </span>
<a name="l00083"></a>00083 <span class="comment"> * so its table can contain any type of objects, but they all must be unnamed.</span>
<a name="l00084"></a>00084 <span class="comment"> * \ingroup point */</span>
<a name="l00085"></a>00085 <span class="keywordtype">int</span> <a class="code" href="group__point.html#gaa096618b3bb044398fb95c550f53b540">imProcessMultiPointOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>** src_image, <span class="keywordtype">int</span> src_count, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <a class="code" href="group__point.html#gae69c44788e933d5ae7db7c77b7816da6">imMultiPointOpFunc</a> func, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keyword">const</span> <span class="keywordtype">char</span>* op_name);
<a name="l00086"></a>00086 <span class="comment"></span>
<a name="l00087"></a>00087 <span class="comment">/** Custom multiple point color funtion.</span>
<a name="l00088"></a>00088 <span class="comment"> * \verbatim func(src_value1_plane0: number, src_value1_plane1: number, ..., src_value2_plane0: number, src_value2_plane1: number, ... , params1, param2, ..., x: number, y: number) -&gt; dst_value_plane0: number, dst_value_plane1: number, ...  [in Lua 5] \endverbatim</span>
<a name="l00089"></a>00089 <span class="comment"> * In Lua, the source images data and the params table are unpacked.</span>
<a name="l00090"></a>00090 <span class="comment"> * Also each color plane is passed as a separe value, instead of inside an array.</span>
<a name="l00091"></a>00091 <span class="comment"> * And the returned value contains only the destiny values to update, or nil (also no return value) to leave destiny intact.</span>
<a name="l00092"></a>00092 <span class="comment"> * \ingroup point */</span>
<a name="l00093"></a><a class="code" href="group__point.html#ga11862724e52576101dcba362756677af">00093</a> <span class="keyword">typedef</span> int (*<a class="code" href="group__point.html#ga11862724e52576101dcba362756677af">imMultiPointColorOpFunc</a>)(<span class="keywordtype">float</span>* src_value, <span class="keywordtype">float</span>* dst_value, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
<a name="l00094"></a>00094 <span class="comment"></span>
<a name="l00095"></a>00095 <span class="comment">/** Apply an multiple point color operation using a custom function.</span>
<a name="l00096"></a>00096 <span class="comment"> * One pixel from each source affects the same pixel on destiny. \n</span>
<a name="l00097"></a>00097 <span class="comment"> * All source images must match in size, depth and data type.</span>
<a name="l00098"></a>00098 <span class="comment"> * Can be done in-place, source and destiny must match size, depth can be different.</span>
<a name="l00099"></a>00099 <span class="comment"> * Data type can be different between sources and destiny, but IM_CFLOAT is not supported. \n</span>
<a name="l00100"></a>00100 <span class="comment"> * op_name is used only by the counter and can be NULL. Data will be set only if cond is true. </span>
<a name="l00101"></a>00101 <span class="comment"> * Returns zero if the counter aborted.</span>
<a name="l00102"></a>00102 <span class="comment"> *</span>
<a name="l00103"></a>00103 <span class="comment"> * \verbatim im.ProcessMultiPointColorOp(src_image: table of imImage, dst_image: imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00104"></a>00104 <span class="comment"> * \verbatim im.ProcessMultiPointColorOpNew(src_image: table of imImage, func: function, params: table, [op_name: string]) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00105"></a>00105 <span class="comment"> * In Lua, the params table is passed to the function by using the Lua stack, </span>
<a name="l00106"></a>00106 <span class="comment"> * so its table can contain any type of objects, but they all must be unnamed.</span>
<a name="l00107"></a>00107 <span class="comment"> * \ingroup point */</span>
<a name="l00108"></a>00108 <span class="keywordtype">int</span> <a class="code" href="group__point.html#ga2c6b5718a76ce2b10e8ba9da9b63c270">imProcessMultiPointColorOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>** src_image, <span class="keywordtype">int</span> src_count, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <a class="code" href="group__point.html#ga11862724e52576101dcba362756677af">imMultiPointColorOpFunc</a> func, <span class="keywordtype">float</span>* params, <span class="keywordtype">void</span>* userdata, <span class="keyword">const</span> <span class="keywordtype">char</span>* op_name);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment"></span>
<a name="l00112"></a>00112 <span class="comment">/** \defgroup arithm Arithmetic Operations </span>
<a name="l00113"></a>00113 <span class="comment"> * \par</span>
<a name="l00114"></a>00114 <span class="comment"> * Simple math operations for images.</span>
<a name="l00115"></a>00115 <span class="comment"> * \par</span>
<a name="l00116"></a>00116 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00117"></a>00117 <span class="comment"> * \ingroup process */</span>
<a name="l00118"></a>00118 <span class="comment"></span>
<a name="l00119"></a>00119 <span class="comment">/** Unary Arithmetic Operations. \n</span>
<a name="l00120"></a>00120 <span class="comment"> * (#) Inverse and log may lead to math exceptions.</span>
<a name="l00121"></a>00121 <span class="comment"> * \ingroup arithm */</span>
<a name="l00122"></a><a class="code" href="group__arithm.html#ga9ad294dc272a13137f7ec549cfda915b">00122</a> <span class="keyword">enum</span> <a class="code" href="group__arithm.html#ga9ad294dc272a13137f7ec549cfda915b">imUnaryOp</a> {
<a name="l00123"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915baec619c98ad4d7b9004e5946dd6712ff7">00123</a>   IM_UN_EQL,     <span class="comment">/**&lt; equal             = a              */</span>
<a name="l00124"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba1000b4ded10e4329a32baec467922b35">00124</a>   IM_UN_ABS,     <span class="comment">/**&lt; abssolute         = |a|            */</span>
<a name="l00125"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915baf18ac1b80509d9d1e8c8721b205d53e2">00125</a>   IM_UN_LESS,    <span class="comment">/**&lt; less              = -a             */</span>
<a name="l00126"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba13046e96f9779230e80de83873f8b44e">00126</a>   IM_UN_INV,     <span class="comment">/**&lt; invert (#)        = 1/a            */</span>
<a name="l00127"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bad7ff984ae00337005fb15852856ff3a2">00127</a>   IM_UN_SQR,     <span class="comment">/**&lt; square            = a*a            */</span>
<a name="l00128"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba1e0a44dad1a60f02e1a0fac221dc3cfb">00128</a>   IM_UN_SQRT,    <span class="comment">/**&lt; square root       = a^(1/2)        */</span>
<a name="l00129"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba09e257aff48b6a86ae75557500cee391">00129</a>   IM_UN_LOG,     <span class="comment">/**&lt; natural logarithm (#) =  ln(a)     */</span>
<a name="l00130"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bad83c28ec4ef2aac0ac3ba1ffd758e0d9">00130</a>   IM_UN_EXP,     <span class="comment">/**&lt; exponential       = exp(a)         */</span>
<a name="l00131"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bae139b110a39eadc742ed25079bcf6f1a">00131</a>   IM_UN_SIN,     <span class="comment">/**&lt; sine              = sin(a)         */</span>
<a name="l00132"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba31127283e0a06247312a2733a71215a3">00132</a>   IM_UN_COS,     <span class="comment">/**&lt; cosine            = cos(a)         */</span>
<a name="l00133"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba2ea89794bd83ea06948628a4fb1aeb44">00133</a>   IM_UN_CONJ,    <span class="comment">/**&lt; complex conjugate = ar - ai*i      */</span>
<a name="l00134"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bacdbe277985ef71fc0995c83b95b70035">00134</a>   IM_UN_CPXNORM, <span class="comment">/**&lt; complex normalization by magnitude = a / cpxmag(a)  */</span>
<a name="l00135"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba02149bd832d4f75c267a72df695b67a1">00135</a>   IM_UN_POSITIVES, <span class="comment">/**&lt; positives       = if a&lt;0 then a=0   */</span>
<a name="l00136"></a><a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bacf4016ad2dd6b1dd3d1768309b7c6f7c">00136</a>   <a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bacf4016ad2dd6b1dd3d1768309b7c6f7c">IM_UN_NEGATIVES</a>  <span class="comment">/**&lt; negatives       = if a&gt;0 then a=0   */</span>
<a name="l00137"></a>00137 };
<a name="l00138"></a>00138 <span class="comment"></span>
<a name="l00139"></a>00139 <span class="comment">/** Apply an arithmetic unary operation. \n</span>
<a name="l00140"></a>00140 <span class="comment"> * Can be done in-place, images must match size. \n</span>
<a name="l00141"></a>00141 <span class="comment"> * Destiny image can be several types depending on source: \n</span>
<a name="l00142"></a>00142 <span class="comment"> * \li byte -&gt; byte, short, ushort, int, float</span>
<a name="l00143"></a>00143 <span class="comment"> * \li ushort -&gt; byte, short, ushort, int, float</span>
<a name="l00144"></a>00144 <span class="comment"> * \li int -&gt; byte, short, ushort, int, float</span>
<a name="l00145"></a>00145 <span class="comment"> * \li float -&gt; float</span>
<a name="l00146"></a>00146 <span class="comment"> * \li complex -&gt; complex</span>
<a name="l00147"></a>00147 <span class="comment"> * If destiny is byte, then the result is cropped to 0-255.</span>
<a name="l00148"></a>00148 <span class="comment"> *</span>
<a name="l00149"></a>00149 <span class="comment"> * \verbatim im.ProcessUnArithmeticOp(src_image: imImage, dst_image: imImage, op: number) [in Lua 5] \endverbatim</span>
<a name="l00150"></a>00150 <span class="comment"> * \verbatim im.ProcessUnArithmeticOpNew(image: imImage, op: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00151"></a>00151 <span class="comment"> * \ingroup arithm */</span>
<a name="l00152"></a>00152 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#ga2c02474eb3d5e3414330381a784161c4">imProcessUnArithmeticOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> op);
<a name="l00153"></a>00153 <span class="comment"></span>
<a name="l00154"></a>00154 <span class="comment">/** Binary Arithmetic Operations. \n</span>
<a name="l00155"></a>00155 <span class="comment"> * Divide may lead to math exceptions.</span>
<a name="l00156"></a>00156 <span class="comment"> * \ingroup arithm */</span>
<a name="l00157"></a><a class="code" href="group__arithm.html#gae5fb5538ff247518a2066b9ef44e1894">00157</a> <span class="keyword">enum</span> <a class="code" href="group__arithm.html#gae5fb5538ff247518a2066b9ef44e1894">imBinaryOp</a> {
<a name="l00158"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a68dfbb4b7b69d4a16d9499731d1fdd35">00158</a>   IM_BIN_ADD,    <span class="comment">/**&lt; add         =    a+b            */</span>
<a name="l00159"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a3268b0a11ec3d02760a6c531a1866001">00159</a>   IM_BIN_SUB,    <span class="comment">/**&lt; subtract    =    a-b            */</span>
<a name="l00160"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894af7fb2393fa5db3450ee0d7c1a359f539">00160</a>   IM_BIN_MUL,    <span class="comment">/**&lt; multiply    =    a*b            */</span>
<a name="l00161"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a1b3ff747082e6d62240aab53741ff27d">00161</a>   IM_BIN_DIV,    <span class="comment">/**&lt; divide      =    a/b            (#) */</span>
<a name="l00162"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a00af36f94432d293809df8d2fbd07296">00162</a>   IM_BIN_DIFF,   <span class="comment">/**&lt; difference  =    |a-b|          */</span>
<a name="l00163"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a68c2aa2940cafcceeebebf6cd0c4bae1">00163</a>   IM_BIN_POW,    <span class="comment">/**&lt; power       =    a^b            */</span>
<a name="l00164"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a9a6610002a1729ee8bf07d472bb52764">00164</a>   IM_BIN_MIN,    <span class="comment">/**&lt; minimum     =    (a &lt; b)? a: b  */</span>
<a name="l00165"></a><a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894ad6025d6dbad2496713272c3b3b2f7a1b">00165</a>   <a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894ad6025d6dbad2496713272c3b3b2f7a1b">IM_BIN_MAX</a>     <span class="comment">/**&lt; maximum     =    (a &gt; b)? a: b  */</span>
<a name="l00166"></a>00166 };
<a name="l00167"></a>00167 <span class="comment"></span>
<a name="l00168"></a>00168 <span class="comment">/** Apply a binary arithmetic operation. \n</span>
<a name="l00169"></a>00169 <span class="comment"> * Can be done in-place, images must match size. \n</span>
<a name="l00170"></a>00170 <span class="comment"> * Source images must match type, destiny image can be several types depending on source: \n</span>
<a name="l00171"></a>00171 <span class="comment"> * \li byte -&gt; byte, short, ushort, int, float</span>
<a name="l00172"></a>00172 <span class="comment"> * \li ushort -&gt; short, ushort, int, float</span>
<a name="l00173"></a>00173 <span class="comment"> * \li int -&gt; int, float</span>
<a name="l00174"></a>00174 <span class="comment"> * \li float -&gt; float</span>
<a name="l00175"></a>00175 <span class="comment"> * \li complex -&gt; complex</span>
<a name="l00176"></a>00176 <span class="comment"> * One exception is that you can combine complex with float resulting complex.</span>
<a name="l00177"></a>00177 <span class="comment"> * If destiny is byte, then the result is cropped to 0-255.</span>
<a name="l00178"></a>00178 <span class="comment"> * Alpha channel is not included.</span>
<a name="l00179"></a>00179 <span class="comment"> *</span>
<a name="l00180"></a>00180 <span class="comment"> * \verbatim im.ProcessArithmeticOp(src_image1: imImage, src_image2: imImage, dst_image: imImage, op: number) [in Lua 5] \endverbatim</span>
<a name="l00181"></a>00181 <span class="comment"> * \verbatim im.ProcessArithmeticOpNew(image1: imImage, image2: imImage, op: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00182"></a>00182 <span class="comment"> * The New function will create a new image of the same type of the source images.</span>
<a name="l00183"></a>00183 <span class="comment"> * \ingroup arithm */</span>
<a name="l00184"></a>00184 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#gae4150398e7c7554a92300e607bd9f9a4">imProcessArithmeticOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> op);
<a name="l00185"></a>00185 <span class="comment"></span>
<a name="l00186"></a>00186 <span class="comment">/** Apply a binary arithmetic operation with a constant value. \n</span>
<a name="l00187"></a>00187 <span class="comment"> * Can be done in-place, images must match size. \n</span>
<a name="l00188"></a>00188 <span class="comment"> * Destiny image can be several types depending on source: \n</span>
<a name="l00189"></a>00189 <span class="comment"> * \li byte -&gt; byte, short, ushort, int, float</span>
<a name="l00190"></a>00190 <span class="comment"> * \li ushort -&gt; byte, short, ushort, int, float</span>
<a name="l00191"></a>00191 <span class="comment"> * \li int -&gt; byte, short, ushort, int, float</span>
<a name="l00192"></a>00192 <span class="comment"> * \li float -&gt; float</span>
<a name="l00193"></a>00193 <span class="comment"> * \li complex -&gt; complex</span>
<a name="l00194"></a>00194 <span class="comment"> * The constant value is type casted to an apropriate type before the operation.</span>
<a name="l00195"></a>00195 <span class="comment"> * If destiny is byte, then the result is cropped to 0-255.</span>
<a name="l00196"></a>00196 <span class="comment"> *</span>
<a name="l00197"></a>00197 <span class="comment"> * \verbatim im.ProcessArithmeticConstOp(src_image: imImage, src_const: number, dst_image: imImage, op: number) [in Lua 5] \endverbatim</span>
<a name="l00198"></a>00198 <span class="comment"> * \verbatim im.ProcessArithmeticConstOpNew(image: imImage, src_const: number, op: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00199"></a>00199 <span class="comment"> * \ingroup arithm */</span>
<a name="l00200"></a>00200 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#ga1d1a4bd1c0f935afeb820cc2fb7c7f7b">imProcessArithmeticConstOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <span class="keywordtype">float</span> src_const, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> op);
<a name="l00201"></a>00201 <span class="comment"></span>
<a name="l00202"></a>00202 <span class="comment">/** Blend two images using an alpha value = [a * alpha + b * (1 - alpha)]. \n</span>
<a name="l00203"></a>00203 <span class="comment"> * Can be done in-place, images must match size and type. \n</span>
<a name="l00204"></a>00204 <span class="comment"> * alpha value must be in the interval [0.0 - 1.0].</span>
<a name="l00205"></a>00205 <span class="comment"> *</span>
<a name="l00206"></a>00206 <span class="comment"> * \verbatim im.ProcessBlendConst(src_image1: imImage, src_image2: imImage, dst_image: imImage, alpha: number) [in Lua 5] \endverbatim</span>
<a name="l00207"></a>00207 <span class="comment"> * \verbatim im.ProcessBlendConstNew(image1: imImage, image2: imImage, alpha: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00208"></a>00208 <span class="comment"> * \ingroup arithm */</span>
<a name="l00209"></a>00209 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#gaa7149d9178bf72e67845a69f210b531f">imProcessBlendConst</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> alpha);
<a name="l00210"></a>00210 <span class="comment"></span>
<a name="l00211"></a>00211 <span class="comment">/** Blend two images using an alpha channel = [a * alpha + b * (1 - alpha)]. \n</span>
<a name="l00212"></a>00212 <span class="comment"> * Can be done in-place, images must match size and type. \n</span>
<a name="l00213"></a>00213 <span class="comment"> * alpha_image must have the same data type except for complex images that must be float, and color_space must be IM_GRAY.</span>
<a name="l00214"></a>00214 <span class="comment"> * Maximum alpha values are baed in \ref imColorMax. Minimum is always 0.</span>
<a name="l00215"></a>00215 <span class="comment"> * \verbatim im.ProcessBlend(src_image1: imImage, src_image2: imImage, alpha_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00216"></a>00216 <span class="comment"> * \verbatim im.ProcessBlendNew(image1: imImage, image2: imImage, alpha_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00217"></a>00217 <span class="comment"> * \ingroup arithm */</span>
<a name="l00218"></a>00218 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#ga64d21be0d738075e6df8a5f501e6a7b5">imProcessBlend</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* alpha_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00219"></a>00219 <span class="comment"></span>
<a name="l00220"></a>00220 <span class="comment">/** Compose two images that have an alpha channel using the OVER operator. \n</span>
<a name="l00221"></a>00221 <span class="comment"> * Can be done in-place, images must match size and type. \n</span>
<a name="l00222"></a>00222 <span class="comment"> * Maximum alpha values are baed in \ref imColorMax. Minimum is always 0.</span>
<a name="l00223"></a>00223 <span class="comment"> * \verbatim im.ProcessCompose(src_image1: imImage, src_image2: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00224"></a>00224 <span class="comment"> * \verbatim im.ProcessComposeNew(image1: imImage, image2: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00225"></a>00225 <span class="comment"> * \ingroup arithm */</span>
<a name="l00226"></a>00226 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#gaf25da0ee5698ee8bfde2f1c1037de60d">imProcessCompose</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment">/** Split a complex image into two images with real and imaginary parts \n</span>
<a name="l00229"></a>00229 <span class="comment"> * or magnitude and phase parts (polar). \n</span>
<a name="l00230"></a>00230 <span class="comment"> * Source image must be IM_CFLOAT, destiny images must be IM_FLOAT.</span>
<a name="l00231"></a>00231 <span class="comment"> *</span>
<a name="l00232"></a>00232 <span class="comment"> * \verbatim im.ProcessSplitComplex(src_image: imImage, dst_image1: imImage, dst_image2: imImage, polar: boolean) [in Lua 5] \endverbatim</span>
<a name="l00233"></a>00233 <span class="comment"> * \verbatim im.ProcessSplitComplexNew(image: imImage, polar: boolean) -&gt; dst_image1: imImage, dst_image2: imImage [in Lua 5] \endverbatim</span>
<a name="l00234"></a>00234 <span class="comment"> * \ingroup arithm */</span>
<a name="l00235"></a>00235 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#gaad8b537563985dcdb2c924d6d822d7b3">imProcessSplitComplex</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image1, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image2, <span class="keywordtype">int</span> polar);
<a name="l00236"></a>00236 <span class="comment"></span>
<a name="l00237"></a>00237 <span class="comment">/** Merges two images as the real and imaginary parts of a complex image, \n</span>
<a name="l00238"></a>00238 <span class="comment"> * or as magnitude and phase parts (polar = 1). \n</span>
<a name="l00239"></a>00239 <span class="comment"> * Source images must be IM_FLOAT, destiny image must be IM_CFLOAT.</span>
<a name="l00240"></a>00240 <span class="comment"> *</span>
<a name="l00241"></a>00241 <span class="comment"> * \verbatim im.ProcessMergeComplex(src_image1: imImage, src_image2: imImage, dst_image: imImage, polar: boolean) [in Lua 5] \endverbatim</span>
<a name="l00242"></a>00242 <span class="comment"> * \verbatim im.ProcessMergeComplexNew(image1: imImage, image2: imImage, polar: boolean) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00243"></a>00243 <span class="comment"> * \ingroup arithm */</span>
<a name="l00244"></a>00244 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#gafc5d9030516644575df4ca8f234a5153">imProcessMergeComplex</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> polar);
<a name="l00245"></a>00245 <span class="comment"></span>
<a name="l00246"></a>00246 <span class="comment">/** Calculates the mean of multiple images. \n</span>
<a name="l00247"></a>00247 <span class="comment"> * Images must match size and type.</span>
<a name="l00248"></a>00248 <span class="comment"> *</span>
<a name="l00249"></a>00249 <span class="comment"> * \verbatim im.ProcessMultipleMean(src_image_list: table of imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00250"></a>00250 <span class="comment"> * \verbatim im.ProcessMultipleMeanNew(src_image_list: table of imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00251"></a>00251 <span class="comment"> * \ingroup arithm */</span>
<a name="l00252"></a>00252 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#gae96f6422f02f2573ca7f2f5ead2fd872">imProcessMultipleMean</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>** src_image_list, <span class="keywordtype">int</span> src_image_count, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00253"></a>00253 <span class="comment"></span>
<a name="l00254"></a>00254 <span class="comment">/** Calculates the standard deviation of multiple images. \n</span>
<a name="l00255"></a>00255 <span class="comment"> * Images must match size and type. Use \ref imProcessMultipleMean to calculate the mean_image.</span>
<a name="l00256"></a>00256 <span class="comment"> *</span>
<a name="l00257"></a>00257 <span class="comment"> * \verbatim im.ProcessMultipleStdDev(src_image_list: table of imImage, mean_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00258"></a>00258 <span class="comment"> * \verbatim im.ProcessMultipleStdDevNew(src_image_list: table of imImage, mean_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00259"></a>00259 <span class="comment"> * \ingroup arithm */</span>
<a name="l00260"></a>00260 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#ga7f87abbc404ff7cb4db95e682cf92399">imProcessMultipleStdDev</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>** src_image_list, <span class="keywordtype">int</span> src_image_count, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a> *mean_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00261"></a>00261 <span class="comment"></span>
<a name="l00262"></a>00262 <span class="comment">/** Calculates the auto-covariance of an image with the mean of a set of images. \n</span>
<a name="l00263"></a>00263 <span class="comment"> * Images must match size and type. Returns zero if the counter aborted. \n</span>
<a name="l00264"></a>00264 <span class="comment"> * Destiny is IM_FLOAT.</span>
<a name="l00265"></a>00265 <span class="comment"> * Returns zero if the counter aborted.</span>
<a name="l00266"></a>00266 <span class="comment"> *</span>
<a name="l00267"></a>00267 <span class="comment"> * \verbatim im.ProcessAutoCovariance(src_image: imImage, mean_image: imImage, dst_image: imImage) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00268"></a>00268 <span class="comment"> * \verbatim im.ProcessAutoCovarianceNew(src_image: imImage, mean_image: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00269"></a>00269 <span class="comment"> * \ingroup arithm */</span>
<a name="l00270"></a>00270 <span class="keywordtype">int</span> <a class="code" href="group__arithm.html#ga48ce1591eb4f5ec4beeb6ac63ce68e9d">imProcessAutoCovariance</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* mean_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00271"></a>00271 <span class="comment"></span>
<a name="l00272"></a>00272 <span class="comment">/** Multiplies the conjugate of one complex image with another complex image. \n</span>
<a name="l00273"></a>00273 <span class="comment"> * Images must match size. Conj(img1) * img2 \n</span>
<a name="l00274"></a>00274 <span class="comment"> * Can be done in-place.</span>
<a name="l00275"></a>00275 <span class="comment"> *</span>
<a name="l00276"></a>00276 <span class="comment"> * \verbatim im.ProcessMultiplyConj(src_image1: imImage, src_image2: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00277"></a>00277 <span class="comment"> * \verbatim im.ProcessMultiplyConjNew(src_image1: imImage, src_image2: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00278"></a>00278 <span class="comment"> * \ingroup arithm */</span>
<a name="l00279"></a>00279 <span class="keywordtype">void</span> <a class="code" href="group__arithm.html#gab1421ed016c60555c85b418535b8baa6">imProcessMultiplyConj</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00280"></a>00280 
<a name="l00281"></a>00281 
<a name="l00282"></a>00282 <span class="comment"></span>
<a name="l00283"></a>00283 <span class="comment">/** \defgroup quantize Additional Image Quantization Operations</span>
<a name="l00284"></a>00284 <span class="comment"> * \par</span>
<a name="l00285"></a>00285 <span class="comment"> * Additionally operations to the \ref imConvertColorSpace function.</span>
<a name="l00286"></a>00286 <span class="comment"> * \par</span>
<a name="l00287"></a>00287 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00288"></a>00288 <span class="comment"> * \ingroup process */</span>
<a name="l00289"></a>00289 <span class="comment"></span>
<a name="l00290"></a>00290 <span class="comment">/** Converts a RGB image to a MAP image using uniform quantization </span>
<a name="l00291"></a>00291 <span class="comment"> * with an optional 8x8 ordered dither. The RGB image must have data type IM_BYTE.</span>
<a name="l00292"></a>00292 <span class="comment"> *</span>
<a name="l00293"></a>00293 <span class="comment"> * \verbatim im.ProcessQuantizeRGBUniform(src_image: imImage, dst_image: imImage, do_dither: boolean) [in Lua 5] \endverbatim</span>
<a name="l00294"></a>00294 <span class="comment"> * \verbatim im.ProcessQuantizeRGBUniformNew(src_image: imImage, do_dither: boolean) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00295"></a>00295 <span class="comment"> * \ingroup quantize */</span>
<a name="l00296"></a>00296 <span class="keywordtype">void</span> <a class="code" href="group__quantize.html#ga3fce35ab0170cf6624c50b65048df31d">imProcessQuantizeRGBUniform</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> do_dither);
<a name="l00297"></a>00297 <span class="comment"></span>
<a name="l00298"></a>00298 <span class="comment">/** Quantizes a gray scale image in less that 256 grays using uniform quantization. \n</span>
<a name="l00299"></a>00299 <span class="comment"> * Both images must be IM_BYTE/IM_GRAY. Can be done in-place. </span>
<a name="l00300"></a>00300 <span class="comment"> *</span>
<a name="l00301"></a>00301 <span class="comment"> * \verbatim im.ProcessQuantizeGrayUniform(src_image: imImage, dst_image: imImage, grays: number) [in Lua 5] \endverbatim</span>
<a name="l00302"></a>00302 <span class="comment"> * \verbatim im.ProcessQuantizeGrayUniformNew(src_image: imImage, grays: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00303"></a>00303 <span class="comment"> * \ingroup quantize */</span>
<a name="l00304"></a>00304 <span class="keywordtype">void</span> <a class="code" href="group__quantize.html#gabbc71547189e9a4d711a50073059e1f9">imProcessQuantizeGrayUniform</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> grays);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 <span class="comment"></span>
<a name="l00308"></a>00308 <span class="comment">/** \defgroup histo Histogram Based Operations</span>
<a name="l00309"></a>00309 <span class="comment"> * \par</span>
<a name="l00310"></a>00310 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00311"></a>00311 <span class="comment"> * \ingroup process */</span>
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment">/** Performs an histogram expansion based on a percentage of the number of pixels. \n</span>
<a name="l00314"></a>00314 <span class="comment"> * Percentage defines an amount of pixels to include at the lowest level and at the highest level.</span>
<a name="l00315"></a>00315 <span class="comment"> * If it is zero, then only empty counts of the histogram will be considered. \n</span>
<a name="l00316"></a>00316 <span class="comment"> * Images must be (IM_BYTE, IM_SHORT or IM_USHORT)/(IM_RGB or IM_GRAY). Can be done in-place. \n</span>
<a name="l00317"></a>00317 <span class="comment"> * To expand the gammut without using the histogram, by just specifing the lowest and highest levels</span>
<a name="l00318"></a>00318 <span class="comment"> * use the \ref IM_GAMUT_EXPAND tone gammut operation (\ref imProcessToneGamut).</span>
<a name="l00319"></a>00319 <span class="comment"> *</span>
<a name="l00320"></a>00320 <span class="comment"> * \verbatim im.ProcessExpandHistogram(src_image: imImage, dst_image: imImage, percent: number) [in Lua 5] \endverbatim</span>
<a name="l00321"></a>00321 <span class="comment"> * \verbatim im.ProcessExpandHistogramNew(src_image: imImage, percent: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00322"></a>00322 <span class="comment"> * \ingroup histo */</span>
<a name="l00323"></a>00323 <span class="keywordtype">void</span> <a class="code" href="group__histo.html#ga39e1ebc4ec29329336de73753cc11593">imProcessExpandHistogram</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> percent);
<a name="l00324"></a>00324 <span class="comment"></span>
<a name="l00325"></a>00325 <span class="comment">/** Performs an histogram equalization. \n</span>
<a name="l00326"></a>00326 <span class="comment"> * Images must be (IM_BYTE, IM_SHORT or IM_USHORT)/(IM_RGB or IM_GRAY). Can be done in-place. </span>
<a name="l00327"></a>00327 <span class="comment"> *</span>
<a name="l00328"></a>00328 <span class="comment"> * \verbatim im.ProcessEqualizeHistogram(src_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00329"></a>00329 <span class="comment"> * \verbatim im.ProcessEqualizeHistogramNew(src_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00330"></a>00330 <span class="comment"> * \ingroup histo */</span>
<a name="l00331"></a>00331 <span class="keywordtype">void</span> <a class="code" href="group__histo.html#ga44ff3636f553af5ff229eaeb6a01d1b6">imProcessEqualizeHistogram</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="comment"></span>
<a name="l00335"></a>00335 <span class="comment">/** \defgroup colorproc Color Processing Operations</span>
<a name="l00336"></a>00336 <span class="comment"> * \par</span>
<a name="l00337"></a>00337 <span class="comment"> * Operations to change the color components configuration.</span>
<a name="l00338"></a>00338 <span class="comment"> * \par</span>
<a name="l00339"></a>00339 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00340"></a>00340 <span class="comment"> * \ingroup process */</span>
<a name="l00341"></a>00341 <span class="comment"></span>
<a name="l00342"></a>00342 <span class="comment">/** Split a RGB image into luma and chroma. \n</span>
<a name="l00343"></a>00343 <span class="comment"> * Chroma is calculated as R-Y,G-Y,B-Y. Source image must be IM_RGB/IM_BYTE. \n</span>
<a name="l00344"></a>00344 <span class="comment"> * luma image is IM_GRAY/IM_BYTE and chroma is IM_RGB/IM_BYTE. \n</span>
<a name="l00345"></a>00345 <span class="comment"> * Source and destiny must have the same size. </span>
<a name="l00346"></a>00346 <span class="comment"> *</span>
<a name="l00347"></a>00347 <span class="comment"> * \verbatim im.ProcessSplitYChroma(src_image: imImage, y_image: imImage, chroma_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00348"></a>00348 <span class="comment"> * \verbatim im.ProcessSplitYChromaNew(src_image: imImage) -&gt; y_image: imImage, chroma_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00349"></a>00349 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00350"></a>00350 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#ga6bf9aacbf02cd1eaa685ec05ff09a76a">imProcessSplitYChroma</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* y_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* chroma_image);
<a name="l00351"></a>00351 <span class="comment"></span>
<a name="l00352"></a>00352 <span class="comment">/** Split a RGB image into HSI planes. \n</span>
<a name="l00353"></a>00353 <span class="comment"> * Source image must be IM_RGB/IM_BYTE,IM_FLOAT. Destiny images are all IM_GRAY/IM_FLOAT. \n</span>
<a name="l00354"></a>00354 <span class="comment"> * Source images must normalized to 0-1 if type is IM_FLOAT (\ref imProcessToneGamut can be used). See \ref hsi for a definition of the color conversion.\n</span>
<a name="l00355"></a>00355 <span class="comment"> * Source and destiny must have the same size. </span>
<a name="l00356"></a>00356 <span class="comment"> *</span>
<a name="l00357"></a>00357 <span class="comment"> * \verbatim im.ProcessSplitHSI(src_image: imImage, h_image: imImage, s_image: imImage, i_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00358"></a>00358 <span class="comment"> * \verbatim im.ProcessSplitHSINew(src_image: imImage) -&gt; h_image: imImage, s_image: imImage, i_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00359"></a>00359 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00360"></a>00360 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#gaf7ed3a3d64e312dae727ffae32b4cf7c">imProcessSplitHSI</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* h_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* s_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* i_image);
<a name="l00361"></a>00361 <span class="comment"></span>
<a name="l00362"></a>00362 <span class="comment">/** Merge HSI planes into a RGB image. \n</span>
<a name="l00363"></a>00363 <span class="comment"> * Source images must be IM_GRAY/IM_FLOAT. Destiny image can be IM_RGB/IM_BYTE,IM_FLOAT. \n</span>
<a name="l00364"></a>00364 <span class="comment"> * Source and destiny must have the same size. See \ref hsi for a definition of the color conversion.</span>
<a name="l00365"></a>00365 <span class="comment"> *</span>
<a name="l00366"></a>00366 <span class="comment"> * \verbatim im.ProcessMergeHSI(h_image: imImage, s_image: imImage, i_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00367"></a>00367 <span class="comment"> * \verbatim im.ProcessMergeHSINew(h_image: imImage, s_image: imImage, i_image: imImage) -&gt; dst_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00368"></a>00368 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00369"></a>00369 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#gab36eacc040e481d62a3aebcb0ea2fd7c">imProcessMergeHSI</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* h_image, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* s_image, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* i_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00370"></a>00370 <span class="comment"></span>
<a name="l00371"></a>00371 <span class="comment">/** Split a multicomponent image into separate components, including alpha.\n</span>
<a name="l00372"></a>00372 <span class="comment"> * Destiny images must be IM_GRAY. Size and data types must be all the same.\n</span>
<a name="l00373"></a>00373 <span class="comment"> * The number of destiny images must match the depth of the source image, including alpha.</span>
<a name="l00374"></a>00374 <span class="comment"> *</span>
<a name="l00375"></a>00375 <span class="comment"> * \verbatim im.ProcessSplitComponents(src_image: imImage, dst_image_list: table of imImage) [in Lua 5] \endverbatim</span>
<a name="l00376"></a>00376 <span class="comment"> * \verbatim im.ProcessSplitComponentsNew(src_image: imImage) -&gt; dst_image_list: table of imImage [in Lua 5] \endverbatim</span>
<a name="l00377"></a>00377 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00378"></a>00378 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#ga86f9ba50c365da02acefd66872b08cde">imProcessSplitComponents</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>** dst_image_list);
<a name="l00379"></a>00379 <span class="comment"></span>
<a name="l00380"></a>00380 <span class="comment">/** Merges separate components into a multicomponent image, including alpha.\n</span>
<a name="l00381"></a>00381 <span class="comment"> * Source images must be IM_GRAY. Size and data types must be all the same.\n</span>
<a name="l00382"></a>00382 <span class="comment"> * The number of source images must match the depth of the destiny image, including alpha.</span>
<a name="l00383"></a>00383 <span class="comment"> *</span>
<a name="l00384"></a>00384 <span class="comment"> * \verbatim im.ProcessMergeComponents(src_image_list: table of imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00385"></a>00385 <span class="comment"> * \verbatim im.ProcessMergeComponentsNew(src_image_list: table of imImage) -&gt; dst_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00386"></a>00386 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00387"></a>00387 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#ga8fc925f21874f0eb229a6cb9a6272b0a">imProcessMergeComponents</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>** src_image_list, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00388"></a>00388 <span class="comment"></span>
<a name="l00389"></a>00389 <span class="comment">/** Normalize the color components by their sum. Example: c1 = c1/(c1+c2+c3). \n</span>
<a name="l00390"></a>00390 <span class="comment"> * It will not change the alpha channel if any.</span>
<a name="l00391"></a>00391 <span class="comment"> * Destiny image must be IM_FLOAT. </span>
<a name="l00392"></a>00392 <span class="comment"> *</span>
<a name="l00393"></a>00393 <span class="comment"> * \verbatim im.ProcessNormalizeComponents(src_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00394"></a>00394 <span class="comment"> * \verbatim im.ProcessNormalizeComponentsNew(src_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00395"></a>00395 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00396"></a>00396 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#gab70cea634d1bb1aea6bfa90e8594e0ec">imProcessNormalizeComponents</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00397"></a>00397 <span class="comment"></span>
<a name="l00398"></a>00398 <span class="comment">/** Replaces the source color by the destiny color. \n</span>
<a name="l00399"></a>00399 <span class="comment"> * The color will be type casted to the image data type. \n</span>
<a name="l00400"></a>00400 <span class="comment"> * The colors must have the same number of components of the images. \n</span>
<a name="l00401"></a>00401 <span class="comment"> * Supports all color spaces and all data types except IM_CFLOAT.</span>
<a name="l00402"></a>00402 <span class="comment"> *</span>
<a name="l00403"></a>00403 <span class="comment"> * \verbatim im.ProcessReplaceColor(src_image: imImage, dst_image: imImage, src_color: table of numbers, dst_color: table of numbers) [in Lua 5] \endverbatim</span>
<a name="l00404"></a>00404 <span class="comment"> * \verbatim im.ProcessReplaceColorNew(src_image: imImage, src_color: table of numbers, dst_color: table of numbers) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00405"></a>00405 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00406"></a>00406 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#ga964f90285518de585c9c3d54ca6cb5d0">imProcessReplaceColor</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span>* src_color, <span class="keywordtype">float</span>* dst_color);
<a name="l00407"></a>00407 <span class="comment"></span>
<a name="l00408"></a>00408 <span class="comment">/** Sets the alpha channel in destiny where the given color occours in source,</span>
<a name="l00409"></a>00409 <span class="comment"> * elsewhere alpha remains untouched. \n</span>
<a name="l00410"></a>00410 <span class="comment"> * The color must have the same number of components of the source image. \n</span>
<a name="l00411"></a>00411 <span class="comment"> * If destiny does not have an alpha channel, then its plane=0 is used. \n</span>
<a name="l00412"></a>00412 <span class="comment"> * Supports all color spaces for source and all data types except IM_CFLOAT.</span>
<a name="l00413"></a>00413 <span class="comment"> * Images must have the same size.</span>
<a name="l00414"></a>00414 <span class="comment"> *</span>
<a name="l00415"></a>00415 <span class="comment"> * \verbatim im.ProcessSetAlphaColor(src_image: imImage, dst_image: imImage, src_color: table of numbers, dst_alpha: number) [in Lua 5] \endverbatim</span>
<a name="l00416"></a>00416 <span class="comment"> * \ingroup colorproc */</span>
<a name="l00417"></a>00417 <span class="keywordtype">void</span> <a class="code" href="group__colorproc.html#ga7ded0648b9c26603d8a752ba09c394da">imProcessSetAlphaColor</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span>* src_color, <span class="keywordtype">float</span> dst_alpha);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 <span class="comment"></span>
<a name="l00420"></a>00420 <span class="comment">/** \defgroup logic Logical Arithmetic Operations </span>
<a name="l00421"></a>00421 <span class="comment"> * \par</span>
<a name="l00422"></a>00422 <span class="comment"> * Logical binary math operations for images.</span>
<a name="l00423"></a>00423 <span class="comment"> * \par</span>
<a name="l00424"></a>00424 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00425"></a>00425 <span class="comment"> * \ingroup process */</span>
<a name="l00426"></a>00426 <span class="comment"></span>
<a name="l00427"></a>00427 <span class="comment">/** Logical Operations.</span>
<a name="l00428"></a>00428 <span class="comment"> * \ingroup logic */</span>
<a name="l00429"></a><a class="code" href="group__logic.html#gaf9a32020e33868ad00796f5176edd28e">00429</a> <span class="keyword">enum</span> <a class="code" href="group__logic.html#gaf9a32020e33868ad00796f5176edd28e">imLogicOp</a> {
<a name="l00430"></a><a class="code" href="group__logic.html#ggaf9a32020e33868ad00796f5176edd28eac311118a2954b19ce42342e2a3f4f221">00430</a>   IM_BIT_AND,   <span class="comment">/**&lt; and  =   a &amp; b   */</span>
<a name="l00431"></a><a class="code" href="group__logic.html#ggaf9a32020e33868ad00796f5176edd28eab1d3cb5de4bb1903b1ef225c8b484a6a">00431</a>   IM_BIT_OR,    <span class="comment">/**&lt; or   =   a | b   */</span>
<a name="l00432"></a><a class="code" href="group__logic.html#ggaf9a32020e33868ad00796f5176edd28eab92c901f63636f1e71a01459f77c8851">00432</a>   <a class="code" href="group__logic.html#ggaf9a32020e33868ad00796f5176edd28eab92c901f63636f1e71a01459f77c8851">IM_BIT_XOR</a>    <span class="comment">/**&lt; xor  = ~(a | b)  */</span>
<a name="l00433"></a>00433 };
<a name="l00434"></a>00434 <span class="comment"></span>
<a name="l00435"></a>00435 <span class="comment">/** Apply a logical operation.\n</span>
<a name="l00436"></a>00436 <span class="comment"> * Images must have data type integer. Can be done in-place. </span>
<a name="l00437"></a>00437 <span class="comment"> *</span>
<a name="l00438"></a>00438 <span class="comment"> * \verbatim im.ProcessBitwiseOp(src_image1: imImage, src_image2: imImage, dst_image: imImage, op: number) [in Lua 5] \endverbatim</span>
<a name="l00439"></a>00439 <span class="comment"> * \verbatim im.ProcessBitwiseOpNew(src_image1: imImage, src_image2: imImage, op: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00440"></a>00440 <span class="comment"> * \ingroup logic */</span>
<a name="l00441"></a>00441 <span class="keywordtype">void</span> <a class="code" href="group__logic.html#ga4a8852d9c55a3b5bb7abac5422c532b9">imProcessBitwiseOp</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> op);
<a name="l00442"></a>00442 <span class="comment"></span>
<a name="l00443"></a>00443 <span class="comment">/** Apply a logical NOT operation.\n</span>
<a name="l00444"></a>00444 <span class="comment"> * Images must have data type integer. Can be done in-place. </span>
<a name="l00445"></a>00445 <span class="comment"> *</span>
<a name="l00446"></a>00446 <span class="comment"> * \verbatim im.ProcessBitwiseNot(src_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00447"></a>00447 <span class="comment"> * \verbatim im.ProcessBitwiseNotNew(src_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00448"></a>00448 <span class="comment"> * \ingroup logic */</span>
<a name="l00449"></a>00449 <span class="keywordtype">void</span> <a class="code" href="group__logic.html#ga8972cc4dae5494a4efa56640d173252a">imProcessBitwiseNot</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00450"></a>00450 <span class="comment"></span>
<a name="l00451"></a>00451 <span class="comment">/** Apply a bit mask. \n</span>
<a name="l00452"></a>00452 <span class="comment"> * The same as imProcessBitwiseOp but the second image is replaced by a fixed mask. \n</span>
<a name="l00453"></a>00453 <span class="comment"> * Images must have data type IM_BYTE. It is valid only for AND, OR and XOR. Can be done in-place.</span>
<a name="l00454"></a>00454 <span class="comment"> *</span>
<a name="l00455"></a>00455 <span class="comment"> * \verbatim im.ProcessBitMask(src_image: imImage, dst_image: imImage, mask: string, op: number) [in Lua 5] \endverbatim</span>
<a name="l00456"></a>00456 <span class="comment"> * \verbatim im.ProcessBitMaskNew(src_image: imImage, mask: string, op: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00457"></a>00457 <span class="comment"> * In Lua, mask is a string with 0s and 1s, for example: &quot;11001111&quot;.</span>
<a name="l00458"></a>00458 <span class="comment"> * \ingroup logic */</span>
<a name="l00459"></a>00459 <span class="keywordtype">void</span> <a class="code" href="group__logic.html#gab16c256ec53dc704f71eaf4fcc573696">imProcessBitMask</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mask, <span class="keywordtype">int</span> op);
<a name="l00460"></a>00460 <span class="comment"></span>
<a name="l00461"></a>00461 <span class="comment">/** Extract or Reset a bit plane. For ex: 000X0000 or XXX0XXXX (plane=3).\n</span>
<a name="l00462"></a>00462 <span class="comment"> * Images must have data type IM_BYTE. Can be done in-place. </span>
<a name="l00463"></a>00463 <span class="comment"> *</span>
<a name="l00464"></a>00464 <span class="comment"> * \verbatim im.ProcessBitPlane(src_image: imImage, dst_image: imImage, plane: number, do_reset: boolean) [in Lua 5] \endverbatim</span>
<a name="l00465"></a>00465 <span class="comment"> * \verbatim im.ProcessBitPlaneNew(src_image: imImage, plane: number, do_reset: boolean) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00466"></a>00466 <span class="comment"> * \ingroup logic */</span>
<a name="l00467"></a>00467 <span class="keywordtype">void</span> <a class="code" href="group__logic.html#gab8cfd91b6db26a51c5abfeb6418116aa">imProcessBitPlane</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> plane, <span class="keywordtype">int</span> do_reset);
<a name="l00468"></a>00468 
<a name="l00469"></a>00469 
<a name="l00470"></a>00470 <span class="comment"></span>
<a name="l00471"></a>00471 <span class="comment">/** \defgroup render Synthetic Image Render</span>
<a name="l00472"></a>00472 <span class="comment"> * \par</span>
<a name="l00473"></a>00473 <span class="comment"> * Renders some 2D mathematical functions as images. All the functions operates in-place </span>
<a name="l00474"></a>00474 <span class="comment"> * and supports all data types except IM_CFLOAT.</span>
<a name="l00475"></a>00475 <span class="comment"> * \par</span>
<a name="l00476"></a>00476 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00477"></a>00477 <span class="comment"> * \ingroup process */</span>
<a name="l00478"></a>00478 <span class="comment"></span>
<a name="l00479"></a>00479 <span class="comment">/** Render Funtion.</span>
<a name="l00480"></a>00480 <span class="comment"> * \verbatim render_func(x: number, y: number, d: number, params: table) -&gt; value: number [in Lua 5] \endverbatim</span>
<a name="l00481"></a>00481 <span class="comment"> * \ingroup render */</span>
<a name="l00482"></a><a class="code" href="group__render.html#ga638e063551bec295995120e1816735a4">00482</a> <span class="keyword">typedef</span> float (*<a class="code" href="group__render.html#ga638e063551bec295995120e1816735a4">imRenderFunc</a>)(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> d, <span class="keywordtype">float</span>* params);
<a name="l00483"></a>00483 <span class="comment"></span>
<a name="l00484"></a>00484 <span class="comment">/** Render Conditional Funtion.</span>
<a name="l00485"></a>00485 <span class="comment"> * \verbatim render_cond_func(x: number, y: number, d: number, params: table) -&gt; value: number, cond: boolean [in Lua 5] \endverbatim</span>
<a name="l00486"></a>00486 <span class="comment"> * \ingroup render */</span>
<a name="l00487"></a><a class="code" href="group__render.html#ga7f05c984010573978e9b4962bac2b0c9">00487</a> <span class="keyword">typedef</span> float (*<a class="code" href="group__render.html#ga7f05c984010573978e9b4962bac2b0c9">imRenderCondFunc</a>)(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y, <span class="keywordtype">int</span> d, <span class="keywordtype">int</span> *cond, <span class="keywordtype">float</span>* params);
<a name="l00488"></a>00488 <span class="comment"></span>
<a name="l00489"></a>00489 <span class="comment">/** Render a synthetic image using a render function. \n</span>
<a name="l00490"></a>00490 <span class="comment"> * plus will make the render be added to the current image data, </span>
<a name="l00491"></a>00491 <span class="comment"> * or else all data will be replaced. All the render functions use this or the conditional function. \n</span>
<a name="l00492"></a>00492 <span class="comment"> * Returns zero if the counter aborted.</span>
<a name="l00493"></a>00493 <span class="comment"> *</span>
<a name="l00494"></a>00494 <span class="comment"> * \verbatim im.ProcessRenderOp(image: imImage, render_func: function, render_name: string, params: table, plus: boolean) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00495"></a>00495 <span class="comment"> * \ingroup render */</span>
<a name="l00496"></a>00496 <span class="keywordtype">int</span> <a class="code" href="group__render.html#gad7e42a81f33814fb55eddf26def76abd">imProcessRenderOp</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <a class="code" href="group__render.html#ga638e063551bec295995120e1816735a4">imRenderFunc</a> render_func, <span class="keyword">const</span> <span class="keywordtype">char</span>* render_name, <span class="keywordtype">float</span>* params, <span class="keywordtype">int</span> plus);
<a name="l00497"></a>00497 <span class="comment"></span>
<a name="l00498"></a>00498 <span class="comment">/** Render a synthetic image using a conditional render function. \n</span>
<a name="l00499"></a>00499 <span class="comment"> * Data will be rendered only if the condional parameter is true. \n</span>
<a name="l00500"></a>00500 <span class="comment"> * Returns zero if the counter aborted.</span>
<a name="l00501"></a>00501 <span class="comment"> *</span>
<a name="l00502"></a>00502 <span class="comment"> * \verbatim im.ProcessRenderCondOp(image: imImage, render_cond_func: function, render_name: string, params: table) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00503"></a>00503 <span class="comment"> * \ingroup render */</span>
<a name="l00504"></a>00504 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga17ac59071f2032bd88d9455d62057acc">imProcessRenderCondOp</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <a class="code" href="group__render.html#ga7f05c984010573978e9b4962bac2b0c9">imRenderCondFunc</a> render_cond_func, <span class="keyword">const</span> <span class="keywordtype">char</span>* render_name, <span class="keywordtype">float</span>* params);
<a name="l00505"></a>00505 <span class="comment"></span>
<a name="l00506"></a>00506 <span class="comment">/** Render speckle noise on existing data. Can be done in-place.</span>
<a name="l00507"></a>00507 <span class="comment"> *</span>
<a name="l00508"></a>00508 <span class="comment"> * \verbatim im.ProcessRenderAddSpeckleNoise(src_image: imImage, dst_image: imImage, percent: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00509"></a>00509 <span class="comment"> * \verbatim im.ProcessRenderAddSpeckleNoiseNew(src_image: imImage, percent: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00510"></a>00510 <span class="comment"> * \ingroup render */</span>
<a name="l00511"></a>00511 <span class="keywordtype">int</span> <a class="code" href="group__render.html#gaaa757e48840fa09d4f675c2f1338814b">imProcessRenderAddSpeckleNoise</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> percent);
<a name="l00512"></a>00512 <span class="comment"></span>
<a name="l00513"></a>00513 <span class="comment">/** Render gaussian noise on existing data. Can be done in-place.</span>
<a name="l00514"></a>00514 <span class="comment"> *</span>
<a name="l00515"></a>00515 <span class="comment"> * \verbatim im.ProcessRenderAddGaussianNoise(src_image: imImage, dst_image: imImage, mean: number, stddev: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00516"></a>00516 <span class="comment"> * \verbatim im.ProcessRenderAddGaussianNoiseNew(src_image: imImage, mean: number, stddev: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00517"></a>00517 <span class="comment"> * \ingroup render */</span>
<a name="l00518"></a>00518 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga75e77abcf37680e71fbb405828ebabdf">imProcessRenderAddGaussianNoise</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> mean, <span class="keywordtype">float</span> stddev);
<a name="l00519"></a>00519 <span class="comment"></span>
<a name="l00520"></a>00520 <span class="comment">/** Render uniform noise on existing data. Can be done in-place.</span>
<a name="l00521"></a>00521 <span class="comment"> *</span>
<a name="l00522"></a>00522 <span class="comment"> * \verbatim im.ProcessRenderAddUniformNoise(src_image: imImage, dst_image: imImage, mean: number, stddev: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00523"></a>00523 <span class="comment"> * \verbatim im.ProcessRenderAddUniformNoiseNew(src_image: imImage, mean: number, stddev: number) -&gt; counter: boolean, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00524"></a>00524 <span class="comment"> * \ingroup render */</span>
<a name="l00525"></a>00525 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga1d2aabd13792e20fed1b0284f7790966">imProcessRenderAddUniformNoise</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> mean, <span class="keywordtype">float</span> stddev);
<a name="l00526"></a>00526 <span class="comment"></span>
<a name="l00527"></a>00527 <span class="comment">/** Render random noise.</span>
<a name="l00528"></a>00528 <span class="comment"> *</span>
<a name="l00529"></a>00529 <span class="comment"> * \verbatim im.ProcessRenderRandomNoise(image: imImage) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00530"></a>00530 <span class="comment"> * \ingroup render */</span>
<a name="l00531"></a>00531 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga9e44c83347a5135dda670985f94f7921">imProcessRenderRandomNoise</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image);
<a name="l00532"></a>00532 <span class="comment"></span>
<a name="l00533"></a>00533 <span class="comment">/** Render a constant. The number of values must match the depth of the image.</span>
<a name="l00534"></a>00534 <span class="comment"> *</span>
<a name="l00535"></a>00535 <span class="comment"> * \verbatim im.ProcessRenderConstant(image: imImage, value: table of number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00536"></a>00536 <span class="comment"> * \ingroup render */</span>
<a name="l00537"></a>00537 <span class="keywordtype">int</span> <a class="code" href="group__render.html#gae084c4069142a416cd7a291402911d0a">imProcessRenderConstant</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span>* value);
<a name="l00538"></a>00538 <span class="comment"></span>
<a name="l00539"></a>00539 <span class="comment">/** Render a centered wheel.</span>
<a name="l00540"></a>00540 <span class="comment"> *</span>
<a name="l00541"></a>00541 <span class="comment"> * \verbatim im.ProcessRenderWheel(image: imImage, internal_radius: number, external_radius: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00542"></a>00542 <span class="comment"> * \ingroup render */</span>
<a name="l00543"></a>00543 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga8ed0f52ff877645b7e8ace2eca79d322">imProcessRenderWheel</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> internal_radius, <span class="keywordtype">int</span> external_radius);
<a name="l00544"></a>00544 <span class="comment"></span>
<a name="l00545"></a>00545 <span class="comment">/** Render a centered cone.</span>
<a name="l00546"></a>00546 <span class="comment"> *</span>
<a name="l00547"></a>00547 <span class="comment"> * \verbatim im.ProcessRenderCone(image: imImage, radius: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00548"></a>00548 <span class="comment"> * \ingroup render */</span>
<a name="l00549"></a>00549 <span class="keywordtype">int</span> <a class="code" href="group__render.html#gadb29679239b7de8b62e236350e324a5d">imProcessRenderCone</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> radius);
<a name="l00550"></a>00550 <span class="comment"></span>
<a name="l00551"></a>00551 <span class="comment">/** Render a centered tent.</span>
<a name="l00552"></a>00552 <span class="comment"> *</span>
<a name="l00553"></a>00553 <span class="comment"> * \verbatim im.ProcessRenderTent(image: imImage, tent_width: number, tent_height: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00554"></a>00554 <span class="comment"> * \ingroup render */</span>
<a name="l00555"></a>00555 <span class="keywordtype">int</span> <a class="code" href="group__render.html#gad313c790f92ae3033e73190f7e953346">imProcessRenderTent</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> tent_width, <span class="keywordtype">int</span> tent_height);
<a name="l00556"></a>00556 <span class="comment"></span>
<a name="l00557"></a>00557 <span class="comment">/** Render a ramp. Direction can be vertical (1) or horizontal (0).</span>
<a name="l00558"></a>00558 <span class="comment"> *</span>
<a name="l00559"></a>00559 <span class="comment"> * \verbatim im.ProcessRenderRamp(image: imImage, start: number, end: number, vert_dir: boolean) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00560"></a>00560 <span class="comment"> * \ingroup render */</span>
<a name="l00561"></a>00561 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga9fd906494f175c1ee0516d11ad4b06f2">imProcessRenderRamp</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> start, <span class="keywordtype">int</span> end, <span class="keywordtype">int</span> vert_dir);
<a name="l00562"></a>00562 <span class="comment"></span>
<a name="l00563"></a>00563 <span class="comment">/** Render a centered box.</span>
<a name="l00564"></a>00564 <span class="comment"> *</span>
<a name="l00565"></a>00565 <span class="comment"> * \verbatim im.ProcessRenderBox(image: imImage, box_width: number, box_height: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00566"></a>00566 <span class="comment"> * \ingroup render */</span>
<a name="l00567"></a>00567 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga1f33cd6a9e70fc42e5b2b5a724125d5f">imProcessRenderBox</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> box_width, <span class="keywordtype">int</span> box_height);
<a name="l00568"></a>00568 <span class="comment"></span>
<a name="l00569"></a>00569 <span class="comment">/** Render a centered sinc.</span>
<a name="l00570"></a>00570 <span class="comment"> *</span>
<a name="l00571"></a>00571 <span class="comment"> * \verbatim im.ProcessRenderSinc(image: imImage, x_period: number, y_period: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00572"></a>00572 <span class="comment"> * \ingroup render */</span>
<a name="l00573"></a>00573 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga7e429f1d1686066913956abea631f29f">imProcessRenderSinc</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span> x_period, <span class="keywordtype">float</span> y_period);
<a name="l00574"></a>00574 <span class="comment"></span>
<a name="l00575"></a>00575 <span class="comment">/** Render a centered gaussian.</span>
<a name="l00576"></a>00576 <span class="comment"> *</span>
<a name="l00577"></a>00577 <span class="comment"> * \verbatim im.ProcessRenderGaussian(image: imImage, stddev: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00578"></a>00578 <span class="comment"> * \ingroup render */</span>
<a name="l00579"></a>00579 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga68ea099db694acd735414d2acd8e54cc">imProcessRenderGaussian</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span> stddev);
<a name="l00580"></a>00580 <span class="comment"></span>
<a name="l00581"></a>00581 <span class="comment">/** Render the laplacian of a centered gaussian.</span>
<a name="l00582"></a>00582 <span class="comment"> *</span>
<a name="l00583"></a>00583 <span class="comment"> * \verbatim im.ProcessRenderLapOfGaussian(image: imImage, stddev: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00584"></a>00584 <span class="comment"> * \ingroup render */</span>
<a name="l00585"></a>00585 <span class="keywordtype">int</span> <a class="code" href="group__render.html#gadb0f99a4120ba3d7ea1d04558c9c8be2">imProcessRenderLapOfGaussian</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span> stddev);
<a name="l00586"></a>00586 <span class="comment"></span>
<a name="l00587"></a>00587 <span class="comment">/** Render a centered cosine.</span>
<a name="l00588"></a>00588 <span class="comment"> *</span>
<a name="l00589"></a>00589 <span class="comment"> * \verbatim im.ProcessRenderCosine(image: imImage, x_period: number, y_period: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00590"></a>00590 <span class="comment"> * \ingroup render */</span>
<a name="l00591"></a>00591 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga1c7c0ae6089c55237e434749194d3c88">imProcessRenderCosine</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">float</span> x_period, <span class="keywordtype">float</span> y_period);
<a name="l00592"></a>00592 <span class="comment"></span>
<a name="l00593"></a>00593 <span class="comment">/** Render a centered grid.</span>
<a name="l00594"></a>00594 <span class="comment"> *</span>
<a name="l00595"></a>00595 <span class="comment"> * \verbatim im.ProcessRenderGrid(image: imImage, x_space: number, y_space: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00596"></a>00596 <span class="comment"> * \ingroup render */</span>
<a name="l00597"></a>00597 <span class="keywordtype">int</span> <a class="code" href="group__render.html#ga734bad353c60a85ce52d267a4ef11496">imProcessRenderGrid</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> x_space, <span class="keywordtype">int</span> y_space);
<a name="l00598"></a>00598 <span class="comment"></span>
<a name="l00599"></a>00599 <span class="comment">/** Render a centered chessboard.</span>
<a name="l00600"></a>00600 <span class="comment"> *</span>
<a name="l00601"></a>00601 <span class="comment"> * \verbatim im.ProcessRenderChessboard(image: imImage, x_space: number, y_space: number) -&gt; counter: boolean [in Lua 5] \endverbatim</span>
<a name="l00602"></a>00602 <span class="comment"> * \ingroup render */</span>
<a name="l00603"></a>00603 <span class="keywordtype">int</span> <a class="code" href="group__render.html#gaff53c5a6a1c7c993880d1632a9ec294b">imProcessRenderChessboard</a>(<a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> x_space, <span class="keywordtype">int</span> y_space);
<a name="l00604"></a>00604 
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="comment"></span>
<a name="l00607"></a>00607 <span class="comment">/** \defgroup tonegamut Tone Gamut Operations</span>
<a name="l00608"></a>00608 <span class="comment"> * \par</span>
<a name="l00609"></a>00609 <span class="comment"> * Operations that try to preserve the min-max interval in the output (the dynamic range).</span>
<a name="l00610"></a>00610 <span class="comment"> * \par</span>
<a name="l00611"></a>00611 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00612"></a>00612 <span class="comment"> * \ingroup process */</span>
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 <span class="comment"></span>
<a name="l00615"></a>00615 <span class="comment">/** Tone Gamut Operations.</span>
<a name="l00616"></a>00616 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00617"></a><a class="code" href="group__tonegamut.html#gac95db212a048f75572ea26376207316d">00617</a> <span class="keyword">enum</span> <a class="code" href="group__tonegamut.html#gac95db212a048f75572ea26376207316d">imToneGamut</a> {
<a name="l00618"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316dac1f31d49b8901f5ea40f2085ce30485e">00618</a>   IM_GAMUT_NORMALIZE, <span class="comment">/**&lt; normalize = (a-min) / (max-min)     (images must be IM_FLOAT)   */</span>
<a name="l00619"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316da1b39dba64d0303299fe4addc7838816a">00619</a>   IM_GAMUT_POW,       <span class="comment">/**&lt; pow       = ((a-min) / (max-min))^gamma * (max-min) + min                  \n</span>
<a name="l00620"></a>00620 <span class="comment">                                       params[0]=gamma                                             */</span>
<a name="l00621"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316dae487a528dd267e5212128825a0238f2d">00621</a>   IM_GAMUT_LOG,       <span class="comment">/**&lt; log       = log(K * (a-min) / (max-min) + 1))*(max-min)/log(K+1) + min     \n</span>
<a name="l00622"></a>00622 <span class="comment">                                       params[0]=K     (K&gt;0)                                       */</span>
<a name="l00623"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316da04c63e3bf48e86508709d72847a57376">00623</a>   IM_GAMUT_EXP,       <span class="comment">/**&lt; exp       = (exp(K * (a-min) / (max-min)) - 1))*(max-min)/(exp(K)-1) + min \n</span>
<a name="l00624"></a>00624 <span class="comment">                                       params[0]=K                                                 */</span>
<a name="l00625"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316dafe98111788d4542f99ce87a9b32ab547">00625</a>   IM_GAMUT_INVERT,    <span class="comment">/**&lt; invert    = max - (a-min)                                              */</span>
<a name="l00626"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316dacf3b680698ddb09590981f9b59364d0e">00626</a>   IM_GAMUT_ZEROSTART, <span class="comment">/**&lt; zerostart = a - min                                                    */</span>
<a name="l00627"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316da0b0b8b41f998dd1e05cd1af4c8cd3431">00627</a>   IM_GAMUT_SOLARIZE,  <span class="comment">/**&lt; solarize  = a &lt; level ?  a:  (level * (max-min) - a * (level-min)) / (max-level) \n</span>
<a name="l00628"></a>00628 <span class="comment">                                       params[0]=level percentage (0-100) relative to min-max      \n</span>
<a name="l00629"></a>00629 <span class="comment">                                       photography solarization effect. */</span>
<a name="l00630"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316dab5923ba83f8cd1f9d2503040ca975489">00630</a>   IM_GAMUT_SLICE,     <span class="comment">/**&lt; slice     = start &lt; a || a &gt; end ?  min:  binarize?  max: a                     \n</span>
<a name="l00631"></a>00631 <span class="comment">                                       params[0]=start,  params[1]=end,  params[2]=binarize          */</span>
<a name="l00632"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316da8ba1ae2710307a1ff8fd5f92d4454298">00632</a>   IM_GAMUT_EXPAND,    <span class="comment">/**&lt; expand    = a &lt; start ?  min: a &gt; end ? max :  (a-start)*(max-min)/(end-start) + min  \n</span>
<a name="l00633"></a>00633 <span class="comment">                                       params[0]=start,  params[1]=end                              */</span>
<a name="l00634"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316da32538dff2fd5dcdaabde0ba9d14dab7b">00634</a>   IM_GAMUT_CROP,      <span class="comment">/**&lt; crop      = a &lt; start ?  start: a &gt; end ? end : a                                        \n</span>
<a name="l00635"></a>00635 <span class="comment">                                       params[0]=start,  params[1]=end                              */</span>
<a name="l00636"></a><a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316daac5872349bfc76c7f63523a406240295">00636</a>   <a class="code" href="group__tonegamut.html#ggac95db212a048f75572ea26376207316daac5872349bfc76c7f63523a406240295">IM_GAMUT_BRIGHTCONT</a> <span class="comment">/**&lt; brightcont = a &lt; min ?  min:  a &gt; max ?  max:  a * tan(c_a) + b_s + (max-min)*(1 - tan(c_a))/2  \n</span>
<a name="l00637"></a>00637 <span class="comment">                                        params[0]=bright_shift (-100%..+100%),  params[1]=contrast_factor (-100%..+100%)     \n</span>
<a name="l00638"></a>00638 <span class="comment">                                        change brightness and contrast simultaneously. */</span>
<a name="l00639"></a>00639 };
<a name="l00640"></a>00640 <span class="comment"></span>
<a name="l00641"></a>00641 <span class="comment">/** Tone Gamut Flags.</span>
<a name="l00642"></a>00642 <span class="comment"> * Combine with imToneGamut values with bitwise or (|).</span>
<a name="l00643"></a>00643 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00644"></a><a class="code" href="group__tonegamut.html#ga058ee67433c026292429ff0adc90dfa1">00644</a> <span class="keyword">enum</span> <a class="code" href="group__tonegamut.html#ga058ee67433c026292429ff0adc90dfa1">imToneGamutFlags</a> {
<a name="l00645"></a><a class="code" href="group__tonegamut.html#gga058ee67433c026292429ff0adc90dfa1a8002307bf82444da779837dcbfaf9ade">00645</a>   <a class="code" href="group__tonegamut.html#gga058ee67433c026292429ff0adc90dfa1a8002307bf82444da779837dcbfaf9ade">IM_GAMUT_MINMAX</a> = 0x0100 <span class="comment">/**&lt;  min and max are given in params (params[0]=min, params[1]=max), all other parameters shift 2 positions.  */</span>
<a name="l00646"></a>00646 };
<a name="l00647"></a>00647 <span class="comment"></span>
<a name="l00648"></a>00648 <span class="comment">/** Apply a gamut operation with arguments. \n</span>
<a name="l00649"></a>00649 <span class="comment"> * Supports all data types except IM_CFLOAT. \n</span>
<a name="l00650"></a>00650 <span class="comment"> * For IM_GAMUT_NORMALIZE when min &gt; 0 and max &lt; 1, it forces min=0 and max=1. \n</span>
<a name="l00651"></a>00651 <span class="comment"> * IM_BYTE images have min=0 and max=255 always. \n</span>
<a name="l00652"></a>00652 <span class="comment"> * To control min and max values use the IM_GAMUT_MINMAX flag.</span>
<a name="l00653"></a>00653 <span class="comment"> * Can be done in-place. When there is no extra parameters, params can use NULL.</span>
<a name="l00654"></a>00654 <span class="comment"> *</span>
<a name="l00655"></a>00655 <span class="comment"> * \verbatim im.ProcessToneGamut(src_image: imImage, dst_image: imImage, op: number, params: table of number) [in Lua 5] \endverbatim</span>
<a name="l00656"></a>00656 <span class="comment"> * \verbatim im.ProcessToneGamutNew(src_image: imImage, op: number, params: table of number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00657"></a>00657 <span class="comment"> * See also \ref imageenhance.</span>
<a name="l00658"></a>00658 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00659"></a>00659 <span class="keywordtype">void</span> <a class="code" href="group__tonegamut.html#gae15eb527accb2f055ea11f03574ba90e">imProcessToneGamut</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> op, <span class="keywordtype">float</span>* params);
<a name="l00660"></a>00660 <span class="comment"></span>
<a name="l00661"></a>00661 <span class="comment">/** Converts from (0-1) to (0-255), crop out of bounds values. \n</span>
<a name="l00662"></a>00662 <span class="comment"> * Source image must be IM_FLOAT, and destiny image must be IM_BYTE.</span>
<a name="l00663"></a>00663 <span class="comment"> *</span>
<a name="l00664"></a>00664 <span class="comment"> * \verbatim im.ProcessUnNormalize(src_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00665"></a>00665 <span class="comment"> * \verbatim im.ProcessUnNormalizeNew(src_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00666"></a>00666 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00667"></a>00667 <span class="keywordtype">void</span> <a class="code" href="group__tonegamut.html#ga7b775e3cd175eff47d0468aecd227f5c">imProcessUnNormalize</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00668"></a>00668 <span class="comment"></span>
<a name="l00669"></a>00669 <span class="comment">/** Directly converts IM_SHORT, IM_USHORT, IM_INT and IM_FLOAT into IM_BYTE images. \n</span>
<a name="l00670"></a>00670 <span class="comment"> * This can also be done using \ref imConvertDataType with IM_CAST_DIRECT flag.</span>
<a name="l00671"></a>00671 <span class="comment"> *</span>
<a name="l00672"></a>00672 <span class="comment"> * \verbatim im.ProcessDirectConv(src_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00673"></a>00673 <span class="comment"> * \verbatim im.ProcessDirectConvNew(src_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00674"></a>00674 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00675"></a>00675 <span class="keywordtype">void</span> <a class="code" href="group__tonegamut.html#ga4c447514b5627782e29639ad879ecd53">imProcessDirectConv</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00676"></a>00676 <span class="comment"></span>
<a name="l00677"></a>00677 <span class="comment">/** A negative effect. Uses \ref imProcessToneGamut with IM_GAMUT_INVERT for non MAP images. \n</span>
<a name="l00678"></a>00678 <span class="comment"> * Supports all color spaces and all data types except IM_CFLOAT. \n</span>
<a name="l00679"></a>00679 <span class="comment"> * Can be done in-place. </span>
<a name="l00680"></a>00680 <span class="comment"> *</span>
<a name="l00681"></a>00681 <span class="comment"> * \verbatim im.ProcessNegative(src_image: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00682"></a>00682 <span class="comment"> * \verbatim im.ProcessNegativeNew(src_image: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00683"></a>00683 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00684"></a>00684 <span class="keywordtype">void</span> <a class="code" href="group__tonegamut.html#gad4d3ac623e3aa1e6fd70cd00dff7e7e1">imProcessNegative</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00685"></a>00685 <span class="comment"></span>
<a name="l00686"></a>00686 <span class="comment">/** Calculates an automatic gamma factor. \n</span>
<a name="l00687"></a>00687 <span class="comment"> * gamma=log((mean-min)/(max-min))/log(0.5);</span>
<a name="l00688"></a>00688 <span class="comment"> * Usefull for \ref imProcessToneGamut when using IM_GAMUT_POW.</span>
<a name="l00689"></a>00689 <span class="comment"> *</span>
<a name="l00690"></a>00690 <span class="comment"> * \verbatim im.ProcessCalcAutoGamma(image: imImage) -&gt; gamma: number [in Lua 5] \endverbatim</span>
<a name="l00691"></a>00691 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00692"></a>00692 <span class="keywordtype">float</span> <a class="code" href="group__tonegamut.html#gaff2a6a6b8ef76895f5f8a339755d3b7a">imProcessCalcAutoGamma</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image);
<a name="l00693"></a>00693 <span class="comment"></span>
<a name="l00694"></a>00694 <span class="comment">/** Apply a shift using HSI coordinates. \n</span>
<a name="l00695"></a>00695 <span class="comment"> * Supports all data types except IM_CFLOAT. \n</span>
<a name="l00696"></a>00696 <span class="comment"> * Can be done in-place.</span>
<a name="l00697"></a>00697 <span class="comment"> *</span>
<a name="l00698"></a>00698 <span class="comment"> * \verbatim im.ProcessShiftHSI(src_image: imImage, dst_image: imImage, h_shift, s_shift, i_shift: number) [in Lua 5] \endverbatim</span>
<a name="l00699"></a>00699 <span class="comment"> * \verbatim im.ProcessShiftHSI(src_image: imImage, h_shift, s_shift, i_shift: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00700"></a>00700 <span class="comment"> * \ingroup tonegamut */</span>
<a name="l00701"></a>00701 <span class="keywordtype">void</span> <a class="code" href="group__tonegamut.html#ga735079ca65f9b617edb0d19626e9508e">imProcessShiftHSI</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> h_shift, <span class="keywordtype">float</span> s_shift, <span class="keywordtype">float</span> i_shift);
<a name="l00702"></a>00702 
<a name="l00703"></a>00703 <span class="comment"></span>
<a name="l00704"></a>00704 <span class="comment">/** \defgroup threshold Threshold Operations</span>
<a name="l00705"></a>00705 <span class="comment"> * \par</span>
<a name="l00706"></a>00706 <span class="comment"> * Operations that converts a usually IM_GRAY/IM_BYTE image into a IM_BINARY image using several threshold techniques.</span>
<a name="l00707"></a>00707 <span class="comment"> * \par</span>
<a name="l00708"></a>00708 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00709"></a>00709 <span class="comment"> * \ingroup process */</span>
<a name="l00710"></a>00710 <span class="comment"></span>
<a name="l00711"></a>00711 <span class="comment">/** Apply a manual threshold. \n</span>
<a name="l00712"></a>00712 <span class="comment"> * threshold = a &lt;= level ? 0: value \n</span>
<a name="l00713"></a>00713 <span class="comment"> * Normal value is 1 but another common value is 255. Can be done in-place for IM_BYTE source. \n</span>
<a name="l00714"></a>00714 <span class="comment"> * Source color space must be IM_GRAY, and destiny color space must be IM_BINARY.</span>
<a name="l00715"></a>00715 <span class="comment"> * IM_CFLOAT is not supported. \n</span>
<a name="l00716"></a>00716 <span class="comment"> *</span>
<a name="l00717"></a>00717 <span class="comment"> * \verbatim im.ProcessThreshold(src_image: imImage, dst_image: imImage, level: number, value: number) [in Lua 5] \endverbatim</span>
<a name="l00718"></a>00718 <span class="comment"> * \verbatim im.ProcessThresholdNew(src_image: imImage, level: number, value: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00719"></a>00719 <span class="comment"> * \ingroup threshold */</span>
<a name="l00720"></a>00720 <span class="keywordtype">void</span> <a class="code" href="group__threshold.html#ga77314c41838c952cb1c64d9b651c9968">imProcessThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> level, <span class="keywordtype">int</span> value);
<a name="l00721"></a>00721 <span class="comment"></span>
<a name="l00722"></a>00722 <span class="comment">/** Apply a threshold by the difference of two images. \n</span>
<a name="l00723"></a>00723 <span class="comment"> * threshold = a1 &lt;= a2 ? 0: 1   \n</span>
<a name="l00724"></a>00724 <span class="comment"> * Source color space must be IM_GRAY, and destiny color space must be IM_BINARY.</span>
<a name="l00725"></a>00725 <span class="comment"> * IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. \n</span>
<a name="l00726"></a>00726 <span class="comment"> *</span>
<a name="l00727"></a>00727 <span class="comment"> * \verbatim im.ProcessThresholdByDiff(src_image1: imImage, src_image2: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00728"></a>00728 <span class="comment"> * \verbatim im.ProcessThresholdByDiffNew(src_image1: imImage, src_image2: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00729"></a>00729 <span class="comment"> * \ingroup threshold */</span>
<a name="l00730"></a>00730 <span class="keywordtype">void</span> <a class="code" href="group__threshold.html#ga0111808df4575480750bba5ea1bb7fa9">imProcessThresholdByDiff</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00731"></a>00731 <span class="comment"></span>
<a name="l00732"></a>00732 <span class="comment">/** Apply a threshold by the Hysteresis method. \n</span>
<a name="l00733"></a>00733 <span class="comment"> * Hysteresis thersholding of edge pixels. Starting at pixels with a</span>
<a name="l00734"></a>00734 <span class="comment"> * value greater than the HIGH threshold, trace a connected sequence</span>
<a name="l00735"></a>00735 <span class="comment"> * of pixels that have a value greater than the LOW threhsold. \n</span>
<a name="l00736"></a>00736 <span class="comment"> * IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. \n</span>
<a name="l00737"></a>00737 <span class="comment"> * Note: could not find the original source code author name.</span>
<a name="l00738"></a>00738 <span class="comment"> *</span>
<a name="l00739"></a>00739 <span class="comment"> * \verbatim im.ProcessHysteresisThreshold(src_image: imImage, dst_image: imImage, low_thres: number, high_thres: number) [in Lua 5] \endverbatim</span>
<a name="l00740"></a>00740 <span class="comment"> * \verbatim im.ProcessHysteresisThresholdNew(src_image: imImage, low_thres: number, high_thres: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00741"></a>00741 <span class="comment"> * \ingroup threshold */</span>
<a name="l00742"></a>00742 <span class="keywordtype">void</span> <a class="code" href="group__threshold.html#ga7ada706234fb5e51cff920c8d491303f">imProcessHysteresisThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> low_thres, <span class="keywordtype">int</span> high_thres);
<a name="l00743"></a>00743 <span class="comment"></span>
<a name="l00744"></a>00744 <span class="comment">/** Estimates hysteresis low and high threshold levels. \n</span>
<a name="l00745"></a>00745 <span class="comment"> * Image data type can be IM_BYTE, IM_SHORT or IM_USHORT. \n</span>
<a name="l00746"></a>00746 <span class="comment"> * Usefull for \ref imProcessHysteresisThreshold.</span>
<a name="l00747"></a>00747 <span class="comment"> *</span>
<a name="l00748"></a>00748 <span class="comment"> * \verbatim im.ProcessHysteresisThresEstimate(image: imImage) -&gt; low_level: number, high_level: number [in Lua 5] \endverbatim</span>
<a name="l00749"></a>00749 <span class="comment"> * \ingroup threshold */</span>
<a name="l00750"></a>00750 <span class="keywordtype">void</span> <a class="code" href="group__threshold.html#ga9b3284fe7900633aaf566ff91c7106b4">imProcessHysteresisThresEstimate</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> *low_level, <span class="keywordtype">int</span> *high_level);
<a name="l00751"></a>00751 <span class="comment"></span>
<a name="l00752"></a>00752 <span class="comment">/** Calculates the threshold level for manual threshold using an uniform error approach. \n</span>
<a name="l00753"></a>00753 <span class="comment"> * Supports only IM_BYTE images.</span>
<a name="l00754"></a>00754 <span class="comment"> * Extracted from XITE, Copyright 1991, Blab, UiO \n</span>
<a name="l00755"></a>00755 <span class="comment"> * http://www.ifi.uio.no/~blab/Software/Xite/</span>
<a name="l00756"></a>00756 <span class="comment">\verbatim</span>
<a name="l00757"></a>00757 <span class="comment">  Reference:</span>
<a name="l00758"></a>00758 <span class="comment">    S. M. Dunn &amp; D. Harwood &amp; L. S. Davis:</span>
<a name="l00759"></a>00759 <span class="comment">    &quot;Local Estimation of the Uniform Error Threshold&quot;</span>
<a name="l00760"></a>00760 <span class="comment">    IEEE Trans. on PAMI, Vol PAMI-6, No 6, Nov 1984.</span>
<a name="l00761"></a>00761 <span class="comment">  Comments: It only works well on images whith large objects.</span>
<a name="l00762"></a>00762 <span class="comment">  Author: Olav Borgli, BLAB, ifi, UiO</span>
<a name="l00763"></a>00763 <span class="comment">  Image processing lab, Department of Informatics, University of Oslo</span>
<a name="l00764"></a>00764 <span class="comment">\endverbatim</span>
<a name="l00765"></a>00765 <span class="comment"> * Returns the used level.</span>
<a name="l00766"></a>00766 <span class="comment"> *</span>
<a name="l00767"></a>00767 <span class="comment"> * \verbatim im.ProcessUniformErrThreshold(src_image: imImage, dst_image: imImage) -&gt; level: number [in Lua 5] \endverbatim</span>
<a name="l00768"></a>00768 <span class="comment"> * \verbatim im.ProcessUniformErrThresholdNew(src_image: imImage)  -&gt; level: number, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00769"></a>00769 <span class="comment"> * \ingroup threshold */</span>
<a name="l00770"></a>00770 <span class="keywordtype">int</span> <a class="code" href="group__threshold.html#ga22fa1b4d48e642f32c0dc00b76d8b676">imProcessUniformErrThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00771"></a>00771 <span class="comment"></span>
<a name="l00772"></a>00772 <span class="comment">/** Apply a dithering on each image channel by using a difusion error method. \n</span>
<a name="l00773"></a>00773 <span class="comment"> * It can be applied on any IM_BYTE images. It will &quot;threshold&quot; each channel indivudually, so</span>
<a name="l00774"></a>00774 <span class="comment"> * source and destiny must be of the same depth.</span>
<a name="l00775"></a>00775 <span class="comment"> * Not using OpenMP when enabled.</span>
<a name="l00776"></a>00776 <span class="comment"> *</span>
<a name="l00777"></a>00777 <span class="comment"> * \verbatim im.ProcessDifusionErrThreshold(src_image: imImage, dst_image: imImage, level: number) [in Lua 5] \endverbatim</span>
<a name="l00778"></a>00778 <span class="comment"> * \verbatim im.ProcessDifusionErrThresholdNew(src_image: imImage, level: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00779"></a>00779 <span class="comment"> * \ingroup threshold */</span>
<a name="l00780"></a>00780 <span class="keywordtype">void</span> <a class="code" href="group__threshold.html#ga8a69eab40db61b8fd1264a762d8e736e">imProcessDifusionErrThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> level);
<a name="l00781"></a>00781 <span class="comment"></span>
<a name="l00782"></a>00782 <span class="comment">/** Calculates the threshold level for manual threshold using a percentage of pixels</span>
<a name="l00783"></a>00783 <span class="comment"> * that should stay bellow the threshold. \n</span>
<a name="l00784"></a>00784 <span class="comment"> * Image data type can be IM_BYTE, IM_SHORT or IM_USHORT. \n</span>
<a name="l00785"></a>00785 <span class="comment"> * Source color space must be IM_GRAY, and destiny color space must be IM_BINARY.</span>
<a name="l00786"></a>00786 <span class="comment"> * Returns the used level.</span>
<a name="l00787"></a>00787 <span class="comment"> *</span>
<a name="l00788"></a>00788 <span class="comment"> * \verbatim im.ProcessPercentThreshold(src_image: imImage, dst_image: imImage, percent: number) -&gt; level: number [in Lua 5] \endverbatim</span>
<a name="l00789"></a>00789 <span class="comment"> * \verbatim im.ProcessPercentThresholdNew(src_image: imImage, percent: number) -&gt; level: number, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00790"></a>00790 <span class="comment"> * \ingroup threshold */</span>
<a name="l00791"></a>00791 <span class="keywordtype">int</span> <a class="code" href="group__threshold.html#ga1635181632159c6ca5d495fe052c9150">imProcessPercentThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> percent);
<a name="l00792"></a>00792 <span class="comment"></span>
<a name="l00793"></a>00793 <span class="comment">/** Calculates the threshold level for manual threshold using the Otsu approach. \n</span>
<a name="l00794"></a>00794 <span class="comment"> * Image can be IM_BYTE, IM_SHORT or IM_USHORT. \n</span>
<a name="l00795"></a>00795 <span class="comment"> * Source color space must be IM_GRAY, and destiny color space must be IM_BINARY.</span>
<a name="l00796"></a>00796 <span class="comment"> * Returns the used level. \n</span>
<a name="l00797"></a>00797 <span class="comment"> * Original implementation by Flavio Szenberg.</span>
<a name="l00798"></a>00798 <span class="comment"> *</span>
<a name="l00799"></a>00799 <span class="comment"> * \verbatim im.ProcessOtsuThreshold(src_image: imImage, dst_image: imImage) -&gt; level: number [in Lua 5] \endverbatim</span>
<a name="l00800"></a>00800 <span class="comment"> * \verbatim im.ProcessOtsuThresholdNew(src_image: imImage) -&gt; level: number, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00801"></a>00801 <span class="comment"> * \ingroup threshold */</span>
<a name="l00802"></a>00802 <span class="keywordtype">int</span> <a class="code" href="group__threshold.html#ga05c52f3c9d7a78fb887adf69e09b7173">imProcessOtsuThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00803"></a>00803 <span class="comment"></span>
<a name="l00804"></a>00804 <span class="comment">/** Calculates the threshold level for manual threshold using (max-min)/2. \n</span>
<a name="l00805"></a>00805 <span class="comment"> * Returns the used level. \n</span>
<a name="l00806"></a>00806 <span class="comment"> * Source color space must be IM_GRAY, and destiny color space must be IM_BINARY.</span>
<a name="l00807"></a>00807 <span class="comment"> * IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. \n</span>
<a name="l00808"></a>00808 <span class="comment"> *</span>
<a name="l00809"></a>00809 <span class="comment"> * \verbatim im.ProcessMinMaxThreshold(src_image: imImage, dst_image: imImage) -&gt; level: number [in Lua 5] \endverbatim</span>
<a name="l00810"></a>00810 <span class="comment"> * \verbatim im.ProcessMinMaxThresholdNew(src_image: imImage) -&gt; level: number, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00811"></a>00811 <span class="comment"> * \ingroup threshold */</span>
<a name="l00812"></a>00812 <span class="keywordtype">float</span> <a class="code" href="group__threshold.html#gaad37679c55dfe9cf63aa3a899d659109">imProcessMinMaxThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00813"></a>00813 <span class="comment"></span>
<a name="l00814"></a>00814 <span class="comment">/** Estimates Local Max threshold level for images.</span>
<a name="l00815"></a>00815 <span class="comment"> * Image can be IM_BYTE, IM_SHORT or IM_USHORT. \n</span>
<a name="l00816"></a>00816 <span class="comment"> *</span>
<a name="l00817"></a>00817 <span class="comment"> * \verbatim im.ProcessLocalMaxThresEstimate(image: imImage) -&gt; level: number [in Lua 5] \endverbatim</span>
<a name="l00818"></a>00818 <span class="comment"> * \ingroup threshold */</span>
<a name="l00819"></a>00819 <span class="keywordtype">void</span> <a class="code" href="group__threshold.html#ga8b2a8a20abb1fa5728198fae3b40a7ee">imProcessLocalMaxThresEstimate</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image, <span class="keywordtype">int</span> *level);
<a name="l00820"></a>00820 <span class="comment"></span>
<a name="l00821"></a>00821 <span class="comment">/** Apply a manual threshold using an interval. \n</span>
<a name="l00822"></a>00822 <span class="comment"> * threshold = start_level &lt;= a &lt;= end_level ? 1: 0 \n</span>
<a name="l00823"></a>00823 <span class="comment"> * Normal value is 1 but another common value is 255. \n</span>
<a name="l00824"></a>00824 <span class="comment"> * Source color space must be IM_GRAY, and destiny color space must be IM_BINARY.</span>
<a name="l00825"></a>00825 <span class="comment"> * IM_CFLOAT is not supported. Can be done in-place for IM_BYTE source. \n</span>
<a name="l00826"></a>00826 <span class="comment"> *</span>
<a name="l00827"></a>00827 <span class="comment"> * \verbatim im.ProcessSliceThreshold(src_image: imImage, dst_image: imImage, start_level: number, end_level: number) [in Lua 5] \endverbatim</span>
<a name="l00828"></a>00828 <span class="comment"> * \verbatim im.ProcessSliceThresholdNew(src_image: imImage, start_level: number, end_level: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00829"></a>00829 <span class="comment"> * \ingroup threshold */</span>
<a name="l00830"></a>00830 <span class="keywordtype">void</span> <a class="code" href="group__threshold.html#ga22a76045e40b98287a1358397bfd2eda">imProcessSliceThreshold</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">float</span> start_level, <span class="keywordtype">float</span> end_level);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="comment"></span>
<a name="l00833"></a>00833 <span class="comment">/** \defgroup effects Special Effects</span>
<a name="l00834"></a>00834 <span class="comment"> * \par</span>
<a name="l00835"></a>00835 <span class="comment"> * Operations to change image appearance.</span>
<a name="l00836"></a>00836 <span class="comment"> * \par</span>
<a name="l00837"></a>00837 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00838"></a>00838 <span class="comment"> * \ingroup process */</span>
<a name="l00839"></a>00839 
<a name="l00840"></a>00840 <span class="comment"></span>
<a name="l00841"></a>00841 <span class="comment">/** Generates a zoom in effect averaging colors inside a square region. \n</span>
<a name="l00842"></a>00842 <span class="comment"> * Operates only on IM_BYTE images.</span>
<a name="l00843"></a>00843 <span class="comment"> *</span>
<a name="l00844"></a>00844 <span class="comment"> * \verbatim im.ProcessPixelate(src_image: imImage, dst_image: imImage, box_size: number) [in Lua 5] \endverbatim</span>
<a name="l00845"></a>00845 <span class="comment"> * \verbatim im.ProcessPixelateNew(src_image: imImage, box_size: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00846"></a>00846 <span class="comment"> * \ingroup effects */</span>
<a name="l00847"></a>00847 <span class="keywordtype">void</span> <a class="code" href="group__effects.html#ga60bcfa8641e6e3eecc3e4ab77dea5414">imProcessPixelate</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> box_size);
<a name="l00848"></a>00848 <span class="comment"></span>
<a name="l00849"></a>00849 <span class="comment">/** A simple Posterize effect. It reduces the number of colors in the image eliminating </span>
<a name="l00850"></a>00850 <span class="comment"> * less significant bit planes. Can have 1 to 7 levels. See \ref imProcessBitMask. \n</span>
<a name="l00851"></a>00851 <span class="comment"> * Images must have data type IM_BYTE.</span>
<a name="l00852"></a>00852 <span class="comment"> *</span>
<a name="l00853"></a>00853 <span class="comment"> * \verbatim im.ProcessPosterize(src_image: imImage, dst_image: imImage, level: number) [in Lua 5] \endverbatim</span>
<a name="l00854"></a>00854 <span class="comment"> * \verbatim im.ProcessPosterizeNew(src_image: imImage, level: number) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00855"></a>00855 <span class="comment"> * \ingroup effects */</span>
<a name="l00856"></a>00856 <span class="keywordtype">void</span> <a class="code" href="group__effects.html#gac9545bf797a9a5269789075ef633c1df">imProcessPosterize</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> level);
<a name="l00857"></a>00857 
<a name="l00858"></a>00858 <span class="comment"></span>
<a name="l00859"></a>00859 <span class="comment">/** \defgroup remotesens Remote Sensing Operations</span>
<a name="l00860"></a>00860 <span class="comment"> * \par</span>
<a name="l00861"></a>00861 <span class="comment"> * Operations used in Remote Sensing.</span>
<a name="l00862"></a>00862 <span class="comment"> * \par</span>
<a name="l00863"></a>00863 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00864"></a>00864 <span class="comment"> * \ingroup process */</span>
<a name="l00865"></a>00865 
<a name="l00866"></a>00866 <span class="comment"></span>
<a name="l00867"></a>00867 <span class="comment">/** Calculates the Normalized Difference Ratio. \n</span>
<a name="l00868"></a>00868 <span class="comment"> * Uses the formula NormDiffRatio = (a-b)/(a+b), \n</span>
<a name="l00869"></a>00869 <span class="comment"> * The result image has [-1,1] interval. \n</span>
<a name="l00870"></a>00870 <span class="comment"> * Images must be IM_GRAY, and the destiny image must be IM_FLOAT.</span>
<a name="l00871"></a>00871 <span class="comment"> *</span>
<a name="l00872"></a>00872 <span class="comment"> * \verbatim im.ProcessNormDiffRatio(image1: imImage, image2: imImage, dst_image: imImage) [in Lua 5] \endverbatim</span>
<a name="l00873"></a>00873 <span class="comment"> * \verbatim im.ProcessNormDiffRatioNew(image1: imImage, image2: imImage) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00874"></a>00874 <span class="comment"> * \ingroup remotesens */</span>
<a name="l00875"></a>00875 <span class="keywordtype">void</span> <a class="code" href="group__remotesens.html#gaf6d7e40ebc9e78ba2efecfe8f43bbde9">imProcessNormDiffRatio</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image1, <span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image2, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00876"></a>00876 <span class="comment"></span>
<a name="l00877"></a>00877 <span class="comment">/** Applies the abnormal pixel correction as described in the article. \n</span>
<a name="l00878"></a>00878 <span class="comment"> * Images must be IM_GRAY. Source and Destiny must have the same datatype, and IM_CFLOAT is not supported. \n</span>
<a name="l00879"></a>00879 <span class="comment"> * image_abnormal is optional, can be NULL. If not NULL, must be IM_BINARY and </span>
<a name="l00880"></a>00880 <span class="comment"> * it will store the abnormal pixels distribution. \n</span>
<a name="l00881"></a>00881 <span class="comment"> * Can be done in-place. \n</span>
<a name="l00882"></a>00882 <span class="comment"> * threshold_percent is the percentage of the height that must have abnormal pixels candidates. \n</span>
<a name="l00883"></a>00883 <span class="comment"> * threshold_consecutive is the minimum number of consecutive abnormal pixels candidates to be considered an abnormal range. </span>
<a name="l00884"></a>00884 <span class="comment"> * (usually the longest vertical ground feature in pixels)\n </span>
<a name="l00885"></a>00885 <span class="comment"> * \par</span>
<a name="l00886"></a>00886 <span class="comment"> * Based on &quot;Detection and Correction of Abnormal Pixels in Hyperion Images&quot;</span>
<a name="l00887"></a>00887 <span class="comment"> * from T. Han, D. G. Goodenough, A. Dyk, and J. Love</span>
<a name="l00888"></a>00888 <span class="comment"> *</span>
<a name="l00889"></a>00889 <span class="comment"> * \verbatim im.AbnormalHyperionCorrection(src_image: imImage, dst_image: imImage, threshold_consecutive, threshold_percent: number[, image_abnormal: imImage]) [in Lua 5] \endverbatim</span>
<a name="l00890"></a>00890 <span class="comment"> * \verbatim im.AbnormalHyperionCorrectionNew(src_image: imImage, threshold_consecutive, threshold_percent: number[, image_abnormal: imImage]) -&gt; new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00891"></a>00891 <span class="comment"> * \ingroup remotesens */</span>
<a name="l00892"></a>00892 <span class="keywordtype">void</span> <a class="code" href="group__remotesens.html#gafd395041b7b3ce8b4afb1967640f708f">imProcessAbnormalHyperionCorrection</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> threshold_consecutive, <span class="keywordtype">int</span> threshold_percent, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* image_abnormal);
<a name="l00893"></a>00893 
<a name="l00894"></a>00894 <span class="comment"></span>
<a name="l00895"></a>00895 <span class="comment">/** \defgroup procconvert Image Conversion</span>
<a name="l00896"></a>00896 <span class="comment"> * \par</span>
<a name="l00897"></a>00897 <span class="comment"> * Same as imConvert functions but using OpenMP when enabled.</span>
<a name="l00898"></a>00898 <span class="comment"> * \par</span>
<a name="l00899"></a>00899 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00900"></a>00900 <span class="comment"> * \ingroup process */</span>
<a name="l00901"></a>00901 
<a name="l00902"></a>00902 <span class="comment"></span>
<a name="l00903"></a>00903 <span class="comment">/** Same as  \ref imConvertDataType.</span>
<a name="l00904"></a>00904 <span class="comment"> * But returns zero if the counter aborted.</span>
<a name="l00905"></a>00905 <span class="comment"> *</span>
<a name="l00906"></a>00906 <span class="comment"> * \verbatim im.ProcessConvertDataType(src_image: imImage, dst_image: imImage, cpx2real: number, gamma: number, abssolute: boolean, cast_mode: number) -&gt; error: number [in Lua 5] \endverbatim</span>
<a name="l00907"></a>00907 <span class="comment"> * \verbatim im.ProcessConvertDataTypeNew(image: imImage, data_type: number, cpx2real: number, gamma: number, abssolute: boolean, cast_mode: number) -&gt; error: number, new_image: imImage  [in Lua 5] \endverbatim</span>
<a name="l00908"></a>00908 <span class="comment"> * \ingroup procconvert */</span>
<a name="l00909"></a>00909 <span class="keywordtype">int</span> <a class="code" href="group__procconvert.html#gafbb787b75cd39bbe99acbd7b44190280">imProcessConvertDataType</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> cpx2real, <span class="keywordtype">float</span> gamma, <span class="keywordtype">int</span> abssolute, <span class="keywordtype">int</span> cast_mode);
<a name="l00910"></a>00910 <span class="comment"></span>
<a name="l00911"></a>00911 <span class="comment">/** Same as  \ref imConvertColorSpace.</span>
<a name="l00912"></a>00912 <span class="comment"> * But returns zero if the counter aborted.</span>
<a name="l00913"></a>00913 <span class="comment"> *</span>
<a name="l00914"></a>00914 <span class="comment"> * \verbatim im.ProcessConvertColorSpace(src_image: imImage, dst_image: imImage) -&gt; error: number [in Lua 5] \endverbatim</span>
<a name="l00915"></a>00915 <span class="comment"> * \verbatim im.ProcessConvertColorSpaceNew(image: imImage, color_space: number, has_alpha: boolean) -&gt; error: number, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00916"></a>00916 <span class="comment"> * \ingroup procconvert */</span>
<a name="l00917"></a>00917 <span class="keywordtype">int</span> <a class="code" href="group__procconvert.html#ga8198530dd96d19155b643c114b46dc9e">imProcessConvertColorSpace</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image);
<a name="l00918"></a>00918 <span class="comment"></span>
<a name="l00919"></a>00919 <span class="comment">/** Same as  \ref imConvertToBitmap.</span>
<a name="l00920"></a>00920 <span class="comment"> * But returns zero if the counter aborted.</span>
<a name="l00921"></a>00921 <span class="comment"> *</span>
<a name="l00922"></a>00922 <span class="comment"> * \verbatim im.ProcessConvertToBitmap(src_image: imImage, dst_image: imImage, cpx2real: number, gamma: number, abssolute: boolean, cast_mode: number) -&gt; error: number [in Lua 5] \endverbatim</span>
<a name="l00923"></a>00923 <span class="comment"> * \verbatim im.ProcessConvertToBitmapNew(image: imImage, color_space: number, has_alpha: boolean, cpx2real: number, gamma: number, abssolute: boolean, cast_mode: number) -&gt; error: number, new_image: imImage [in Lua 5] \endverbatim</span>
<a name="l00924"></a>00924 <span class="comment"> * \ingroup procconvert */</span>
<a name="l00925"></a>00925 <span class="keywordtype">int</span> <a class="code" href="group__procconvert.html#ga81ff368eedf17dae838ddee069210169">imProcessConvertToBitmap</a>(<span class="keyword">const</span> <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* src_image, <a class="code" href="struct__imImage.html" title="Image Representation Structure.">imImage</a>* dst_image, <span class="keywordtype">int</span> cpx2real, <span class="keywordtype">float</span> gamma, <span class="keywordtype">int</span> abssolute, <span class="keywordtype">int</span> cast_mode);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 <span class="comment"></span>
<a name="l00928"></a>00928 <span class="comment">/** \defgroup imageenhance Image Enhance Utilities in Lua</span>
<a name="l00929"></a>00929 <span class="comment"> * \par</span>
<a name="l00930"></a>00930 <span class="comment"> * Operations are done in-place. Limitations are the same of the original functions.</span>
<a name="l00931"></a>00931 <span class="comment"> * \par</span>
<a name="l00932"></a>00932 <span class="comment"> * See \ref im_process_pnt.h</span>
<a name="l00933"></a>00933 <span class="comment"> * \ingroup process */</span>
<a name="l00934"></a>00934 <span class="comment"></span>
<a name="l00935"></a>00935 <span class="comment">/** Same as \ref imProcessToneGamut using \ref IM_GAMUT_POW.</span>
<a name="l00936"></a>00936 <span class="comment"> *</span>
<a name="l00937"></a>00937 <span class="comment"> * \verbatim image:Gamma(gamma) [in Lua 5] \endverbatim</span>
<a name="l00938"></a>00938 <span class="comment"> * \ingroup imageenhance */</span>
<a name="l00939"></a><a class="code" href="group__imageenhance.html#ga5bd26b30210215f41d26bb2e2d2b3d5f">00939</a> <span class="preprocessor">#define imImageGamma(_image, _gamma) { float params[1]; params[0] = _gamma; imProcessToneGamut(_image, _image, IM_GAMUT_POW, params); }</span>
<a name="l00940"></a>00940 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00941"></a>00941 <span class="comment">/** Same as \ref imProcessToneGamut using \ref IM_GAMUT_BRIGHTCONT.</span>
<a name="l00942"></a>00942 <span class="comment"> *</span>
<a name="l00943"></a>00943 <span class="comment"> * \verbatim image:BrightnessContrast(bright_shift, contrast_factor: number)   [in Lua 5] \endverbatim</span>
<a name="l00944"></a>00944 <span class="comment"> * \ingroup imageenhance */</span>
<a name="l00945"></a><a class="code" href="group__imageenhance.html#ga329fa1b3de895a94d1f54d5154de51db">00945</a> <span class="preprocessor">#define imImageBrightnessContrast(_image, _bright_shift, _contrast_factor) { float _params[2]; _params[0] = bright_shift; _params[1] = contrast_factor; imProcessToneGamut(_image, _image, IM_GAMUT_BRIGHTCONT, _params); }</span>
<a name="l00946"></a>00946 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00947"></a>00947 <span class="comment">/** Same as \ref imProcessToneGamut using \ref IM_GAMUT_EXPAND.</span>
<a name="l00948"></a>00948 <span class="comment"> *</span>
<a name="l00949"></a>00949 <span class="comment"> * \verbatim image:Level(start, end)  [in Lua 5] \endverbatim</span>
<a name="l00950"></a>00950 <span class="comment"> * \ingroup imageenhance */</span>
<a name="l00951"></a><a class="code" href="group__imageenhance.html#ga6219caf79035952ab8d27b7b775d383f">00951</a> <span class="preprocessor">#define imImageLevel(_image, _start, _end) { float _params[2]; _params[0] = _start; _params[1] = _end; imProcessToneGamut(_image, _image, IM_GAMUT_EXPAND, _params); }</span>
<a name="l00952"></a>00952 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00953"></a>00953 <span class="comment">/** Same as \ref imProcessEqualizeHistogram.</span>
<a name="l00954"></a>00954 <span class="comment"> *</span>
<a name="l00955"></a>00955 <span class="comment"> * \verbatim image:Equalize()  [in Lua 5] \endverbatim</span>
<a name="l00956"></a>00956 <span class="comment"> * \ingroup imageenhance */</span>
<a name="l00957"></a><a class="code" href="group__imageenhance.html#gac75c1f3961cf97ab1617e80a313cdd90">00957</a> <span class="preprocessor">#define imImageEqualize(_image) imProcessEqualizeHistogram(_image, _image)</span>
<a name="l00958"></a>00958 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00959"></a>00959 <span class="comment">/** Same as \ref imProcessNegative.</span>
<a name="l00960"></a>00960 <span class="comment"> * Also same as \ref imProcessToneGamut using \ref IM_GAMUT_INVERT.</span>
<a name="l00961"></a>00961 <span class="comment"> *</span>
<a name="l00962"></a>00962 <span class="comment"> * \verbatim image:Negative()  [in Lua 5] \endverbatim</span>
<a name="l00963"></a>00963 <span class="comment"> * \ingroup imageenhance */</span>
<a name="l00964"></a><a class="code" href="group__imageenhance.html#ga0b461b2b2a8b925537d7d9911c4464a0">00964</a> <span class="preprocessor">#define imImageNegative(_image) imProcessNegative(_image, _image)</span>
<a name="l00965"></a>00965 <span class="preprocessor"></span><span class="comment"></span>
<a name="l00966"></a>00966 <span class="comment">/** Same as \ref imProcessExpandHistogram.</span>
<a name="l00967"></a>00967 <span class="comment"> *</span>
<a name="l00968"></a>00968 <span class="comment"> * \verbatim image:AutoLevel(percent)  [in Lua 5] \endverbatim</span>
<a name="l00969"></a>00969 <span class="comment"> * \ingroup imageenhance */</span>
<a name="l00970"></a><a class="code" href="group__imageenhance.html#ga28246a18afdbd59223b642b3b83584dd">00970</a> <span class="preprocessor">#define imImageAutoLevel(_image, _percent) imProcessExpandHistogram(_image, _image, _percent)</span>
<a name="l00971"></a>00971 <span class="preprocessor"></span>
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 <span class="preprocessor">#if defined(__cplusplus)</span>
<a name="l00974"></a>00974 <span class="preprocessor"></span>}
<a name="l00975"></a>00975 <span class="preprocessor">#endif</span>
<a name="l00976"></a>00976 <span class="preprocessor"></span>
<a name="l00977"></a>00977 <span class="preprocessor">#endif</span>
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:06 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
