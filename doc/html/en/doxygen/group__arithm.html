<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>IM: Arithmetic Operations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Arithmetic Operations<br/>
<small>
[<a class="el" href="group__process.html">Image Processing</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p><div class="dynheader">
Collaboration diagram for Arithmetic Operations:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group__arithm.png" border="0" alt="" usemap="#group____arithm"/>
<map name="group____arithm" id="group____arithm">
<area shape="rect" id="node2" href="group__process.html" title="Image Processing" alt="" coords="5,5,160,37"/></map>
</td></tr></table></center>
</div>
</p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#ga9ad294dc272a13137f7ec549cfda915b">imUnaryOp</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915baec619c98ad4d7b9004e5946dd6712ff7">IM_UN_EQL</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba1000b4ded10e4329a32baec467922b35">IM_UN_ABS</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915baf18ac1b80509d9d1e8c8721b205d53e2">IM_UN_LESS</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba13046e96f9779230e80de83873f8b44e">IM_UN_INV</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bad7ff984ae00337005fb15852856ff3a2">IM_UN_SQR</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba1e0a44dad1a60f02e1a0fac221dc3cfb">IM_UN_SQRT</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba09e257aff48b6a86ae75557500cee391">IM_UN_LOG</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bad83c28ec4ef2aac0ac3ba1ffd758e0d9">IM_UN_EXP</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bae139b110a39eadc742ed25079bcf6f1a">IM_UN_SIN</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba31127283e0a06247312a2733a71215a3">IM_UN_COS</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba2ea89794bd83ea06948628a4fb1aeb44">IM_UN_CONJ</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bacdbe277985ef71fc0995c83b95b70035">IM_UN_CPXNORM</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915ba02149bd832d4f75c267a72df695b67a1">IM_UN_POSITIVES</a>, 
<a class="el" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bacf4016ad2dd6b1dd3d1768309b7c6f7c">IM_UN_NEGATIVES</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gae5fb5538ff247518a2066b9ef44e1894">imBinaryOp</a> { <br/>
&nbsp;&nbsp;<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a68dfbb4b7b69d4a16d9499731d1fdd35">IM_BIN_ADD</a>, 
<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a3268b0a11ec3d02760a6c531a1866001">IM_BIN_SUB</a>, 
<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894af7fb2393fa5db3450ee0d7c1a359f539">IM_BIN_MUL</a>, 
<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a1b3ff747082e6d62240aab53741ff27d">IM_BIN_DIV</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a00af36f94432d293809df8d2fbd07296">IM_BIN_DIFF</a>, 
<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a68c2aa2940cafcceeebebf6cd0c4bae1">IM_BIN_POW</a>, 
<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894a9a6610002a1729ee8bf07d472bb52764">IM_BIN_MIN</a>, 
<a class="el" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894ad6025d6dbad2496713272c3b3b2f7a1b">IM_BIN_MAX</a>
<br/>
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#ga2c02474eb3d5e3414330381a784161c4">imProcessUnArithmeticOp</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gae4150398e7c7554a92300e607bd9f9a4">imProcessArithmeticOp</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image1, const <a class="el" href="struct__imImage.html">imImage</a> *src_image2, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#ga1d1a4bd1c0f935afeb820cc2fb7c7f7b">imProcessArithmeticConstOp</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, float src_const, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gaa7149d9178bf72e67845a69f210b531f">imProcessBlendConst</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image1, const <a class="el" href="struct__imImage.html">imImage</a> *src_image2, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, float alpha)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#ga64d21be0d738075e6df8a5f501e6a7b5">imProcessBlend</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image1, const <a class="el" href="struct__imImage.html">imImage</a> *src_image2, const <a class="el" href="struct__imImage.html">imImage</a> *alpha_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gaf25da0ee5698ee8bfde2f1c1037de60d">imProcessCompose</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image1, const <a class="el" href="struct__imImage.html">imImage</a> *src_image2, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gaad8b537563985dcdb2c924d6d822d7b3">imProcessSplitComplex</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image1, <a class="el" href="struct__imImage.html">imImage</a> *dst_image2, int polar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gafc5d9030516644575df4ca8f234a5153">imProcessMergeComplex</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image1, const <a class="el" href="struct__imImage.html">imImage</a> *src_image2, <a class="el" href="struct__imImage.html">imImage</a> *dst_image, int polar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gae96f6422f02f2573ca7f2f5ead2fd872">imProcessMultipleMean</a> (const <a class="el" href="struct__imImage.html">imImage</a> **src_image_list, int src_image_count, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#ga7f87abbc404ff7cb4db95e682cf92399">imProcessMultipleStdDev</a> (const <a class="el" href="struct__imImage.html">imImage</a> **src_image_list, int src_image_count, const <a class="el" href="struct__imImage.html">imImage</a> *mean_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#ga48ce1591eb4f5ec4beeb6ac63ce68e9d">imProcessAutoCovariance</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image, const <a class="el" href="struct__imImage.html">imImage</a> *mean_image, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__arithm.html#gab1421ed016c60555c85b418535b8baa6">imProcessMultiplyConj</a> (const <a class="el" href="struct__imImage.html">imImage</a> *src_image1, const <a class="el" href="struct__imImage.html">imImage</a> *src_image2, <a class="el" href="struct__imImage.html">imImage</a> *dst_image)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b></b></dt><dd>Simple math operations for images. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See <a class="el" href="im__process__pnt_8h.html">im_process_pnt.h</a> </dd></dl>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga9ad294dc272a13137f7ec549cfda915b"></a><!-- doxytag: member="im_process_pnt.h::imUnaryOp" ref="ga9ad294dc272a13137f7ec549cfda915b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__arithm.html#ga9ad294dc272a13137f7ec549cfda915b">imUnaryOp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Unary Arithmetic Operations. <br/>
 (#) Inverse and log may lead to math exceptions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915baec619c98ad4d7b9004e5946dd6712ff7"></a><!-- doxytag: member="IM_UN_EQL" ref="gga9ad294dc272a13137f7ec549cfda915baec619c98ad4d7b9004e5946dd6712ff7" args="" -->IM_UN_EQL</em>&nbsp;</td><td>
<p>equal = a </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915ba1000b4ded10e4329a32baec467922b35"></a><!-- doxytag: member="IM_UN_ABS" ref="gga9ad294dc272a13137f7ec549cfda915ba1000b4ded10e4329a32baec467922b35" args="" -->IM_UN_ABS</em>&nbsp;</td><td>
<p>abssolute = |a| </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915baf18ac1b80509d9d1e8c8721b205d53e2"></a><!-- doxytag: member="IM_UN_LESS" ref="gga9ad294dc272a13137f7ec549cfda915baf18ac1b80509d9d1e8c8721b205d53e2" args="" -->IM_UN_LESS</em>&nbsp;</td><td>
<p>less = -a </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915ba13046e96f9779230e80de83873f8b44e"></a><!-- doxytag: member="IM_UN_INV" ref="gga9ad294dc272a13137f7ec549cfda915ba13046e96f9779230e80de83873f8b44e" args="" -->IM_UN_INV</em>&nbsp;</td><td>
<p>invert (#) = 1/a </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915bad7ff984ae00337005fb15852856ff3a2"></a><!-- doxytag: member="IM_UN_SQR" ref="gga9ad294dc272a13137f7ec549cfda915bad7ff984ae00337005fb15852856ff3a2" args="" -->IM_UN_SQR</em>&nbsp;</td><td>
<p>square = a*a </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915ba1e0a44dad1a60f02e1a0fac221dc3cfb"></a><!-- doxytag: member="IM_UN_SQRT" ref="gga9ad294dc272a13137f7ec549cfda915ba1e0a44dad1a60f02e1a0fac221dc3cfb" args="" -->IM_UN_SQRT</em>&nbsp;</td><td>
<p>square root = a^(1/2) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915ba09e257aff48b6a86ae75557500cee391"></a><!-- doxytag: member="IM_UN_LOG" ref="gga9ad294dc272a13137f7ec549cfda915ba09e257aff48b6a86ae75557500cee391" args="" -->IM_UN_LOG</em>&nbsp;</td><td>
<p>natural logarithm (#) = ln(a) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915bad83c28ec4ef2aac0ac3ba1ffd758e0d9"></a><!-- doxytag: member="IM_UN_EXP" ref="gga9ad294dc272a13137f7ec549cfda915bad83c28ec4ef2aac0ac3ba1ffd758e0d9" args="" -->IM_UN_EXP</em>&nbsp;</td><td>
<p>exponential = exp(a) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915bae139b110a39eadc742ed25079bcf6f1a"></a><!-- doxytag: member="IM_UN_SIN" ref="gga9ad294dc272a13137f7ec549cfda915bae139b110a39eadc742ed25079bcf6f1a" args="" -->IM_UN_SIN</em>&nbsp;</td><td>
<p>sine = sin(a) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915ba31127283e0a06247312a2733a71215a3"></a><!-- doxytag: member="IM_UN_COS" ref="gga9ad294dc272a13137f7ec549cfda915ba31127283e0a06247312a2733a71215a3" args="" -->IM_UN_COS</em>&nbsp;</td><td>
<p>cosine = cos(a) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915ba2ea89794bd83ea06948628a4fb1aeb44"></a><!-- doxytag: member="IM_UN_CONJ" ref="gga9ad294dc272a13137f7ec549cfda915ba2ea89794bd83ea06948628a4fb1aeb44" args="" -->IM_UN_CONJ</em>&nbsp;</td><td>
<p>complex conjugate = ar - ai*i </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915bacdbe277985ef71fc0995c83b95b70035"></a><!-- doxytag: member="IM_UN_CPXNORM" ref="gga9ad294dc272a13137f7ec549cfda915bacdbe277985ef71fc0995c83b95b70035" args="" -->IM_UN_CPXNORM</em>&nbsp;</td><td>
<p>complex normalization by magnitude = a / cpxmag(a) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915ba02149bd832d4f75c267a72df695b67a1"></a><!-- doxytag: member="IM_UN_POSITIVES" ref="gga9ad294dc272a13137f7ec549cfda915ba02149bd832d4f75c267a72df695b67a1" args="" -->IM_UN_POSITIVES</em>&nbsp;</td><td>
<p>positives = if a&lt;0 then a=0 </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga9ad294dc272a13137f7ec549cfda915bacf4016ad2dd6b1dd3d1768309b7c6f7c"></a><!-- doxytag: member="IM_UN_NEGATIVES" ref="gga9ad294dc272a13137f7ec549cfda915bacf4016ad2dd6b1dd3d1768309b7c6f7c" args="" -->IM_UN_NEGATIVES</em>&nbsp;</td><td>
<p>negatives = if a&gt;0 then a=0 </p>
</td></tr>
</table>
</dd>
</dl>

<p><div class="fragment"><pre class="fragment">               {
  IM_UN_EQL,     <span class="comment">/**&lt; equal             = a              */</span>
  IM_UN_ABS,     <span class="comment">/**&lt; abssolute         = |a|            */</span>
  IM_UN_LESS,    <span class="comment">/**&lt; less              = -a             */</span>
  IM_UN_INV,     <span class="comment">/**&lt; invert (#)        = 1/a            */</span>
  IM_UN_SQR,     <span class="comment">/**&lt; square            = a*a            */</span>
  IM_UN_SQRT,    <span class="comment">/**&lt; square root       = a^(1/2)        */</span>
  IM_UN_LOG,     <span class="comment">/**&lt; natural logarithm (#) =  ln(a)     */</span>
  IM_UN_EXP,     <span class="comment">/**&lt; exponential       = exp(a)         */</span>
  IM_UN_SIN,     <span class="comment">/**&lt; sine              = sin(a)         */</span>
  IM_UN_COS,     <span class="comment">/**&lt; cosine            = cos(a)         */</span>
  IM_UN_CONJ,    <span class="comment">/**&lt; complex conjugate = ar - ai*i      */</span>
  IM_UN_CPXNORM, <span class="comment">/**&lt; complex normalization by magnitude = a / cpxmag(a)  */</span>
  IM_UN_POSITIVES, <span class="comment">/**&lt; positives       = if a&lt;0 then a=0   */</span>
  <a class="code" href="group__arithm.html#gga9ad294dc272a13137f7ec549cfda915bacf4016ad2dd6b1dd3d1768309b7c6f7c">IM_UN_NEGATIVES</a>  <span class="comment">/**&lt; negatives       = if a&gt;0 then a=0   */</span>
};
</pre></div></p>

</div>
</div>
<a class="anchor" id="gae5fb5538ff247518a2066b9ef44e1894"></a><!-- doxytag: member="im_process_pnt.h::imBinaryOp" ref="gae5fb5538ff247518a2066b9ef44e1894" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__arithm.html#gae5fb5538ff247518a2066b9ef44e1894">imBinaryOp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Binary Arithmetic Operations. <br/>
 Divide may lead to math exceptions. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894a68dfbb4b7b69d4a16d9499731d1fdd35"></a><!-- doxytag: member="IM_BIN_ADD" ref="ggae5fb5538ff247518a2066b9ef44e1894a68dfbb4b7b69d4a16d9499731d1fdd35" args="" -->IM_BIN_ADD</em>&nbsp;</td><td>
<p>add = a+b </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894a3268b0a11ec3d02760a6c531a1866001"></a><!-- doxytag: member="IM_BIN_SUB" ref="ggae5fb5538ff247518a2066b9ef44e1894a3268b0a11ec3d02760a6c531a1866001" args="" -->IM_BIN_SUB</em>&nbsp;</td><td>
<p>subtract = a-b </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894af7fb2393fa5db3450ee0d7c1a359f539"></a><!-- doxytag: member="IM_BIN_MUL" ref="ggae5fb5538ff247518a2066b9ef44e1894af7fb2393fa5db3450ee0d7c1a359f539" args="" -->IM_BIN_MUL</em>&nbsp;</td><td>
<p>multiply = a*b </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894a1b3ff747082e6d62240aab53741ff27d"></a><!-- doxytag: member="IM_BIN_DIV" ref="ggae5fb5538ff247518a2066b9ef44e1894a1b3ff747082e6d62240aab53741ff27d" args="" -->IM_BIN_DIV</em>&nbsp;</td><td>
<p>divide = a/b (#) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894a00af36f94432d293809df8d2fbd07296"></a><!-- doxytag: member="IM_BIN_DIFF" ref="ggae5fb5538ff247518a2066b9ef44e1894a00af36f94432d293809df8d2fbd07296" args="" -->IM_BIN_DIFF</em>&nbsp;</td><td>
<p>difference = |a-b| </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894a68c2aa2940cafcceeebebf6cd0c4bae1"></a><!-- doxytag: member="IM_BIN_POW" ref="ggae5fb5538ff247518a2066b9ef44e1894a68c2aa2940cafcceeebebf6cd0c4bae1" args="" -->IM_BIN_POW</em>&nbsp;</td><td>
<p>power = a^b </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894a9a6610002a1729ee8bf07d472bb52764"></a><!-- doxytag: member="IM_BIN_MIN" ref="ggae5fb5538ff247518a2066b9ef44e1894a9a6610002a1729ee8bf07d472bb52764" args="" -->IM_BIN_MIN</em>&nbsp;</td><td>
<p>minimum = (a &lt; b)? a: b </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ggae5fb5538ff247518a2066b9ef44e1894ad6025d6dbad2496713272c3b3b2f7a1b"></a><!-- doxytag: member="IM_BIN_MAX" ref="ggae5fb5538ff247518a2066b9ef44e1894ad6025d6dbad2496713272c3b3b2f7a1b" args="" -->IM_BIN_MAX</em>&nbsp;</td><td>
<p>maximum = (a &gt; b)? a: b </p>
</td></tr>
</table>
</dd>
</dl>

<p><div class="fragment"><pre class="fragment">                {
  IM_BIN_ADD,    <span class="comment">/**&lt; add         =    a+b            */</span>
  IM_BIN_SUB,    <span class="comment">/**&lt; subtract    =    a-b            */</span>
  IM_BIN_MUL,    <span class="comment">/**&lt; multiply    =    a*b            */</span>
  IM_BIN_DIV,    <span class="comment">/**&lt; divide      =    a/b            (#) */</span>
  IM_BIN_DIFF,   <span class="comment">/**&lt; difference  =    |a-b|          */</span>
  IM_BIN_POW,    <span class="comment">/**&lt; power       =    a^b            */</span>
  IM_BIN_MIN,    <span class="comment">/**&lt; minimum     =    (a &lt; b)? a: b  */</span>
  <a class="code" href="group__arithm.html#ggae5fb5538ff247518a2066b9ef44e1894ad6025d6dbad2496713272c3b3b2f7a1b">IM_BIN_MAX</a>     <span class="comment">/**&lt; maximum     =    (a &gt; b)? a: b  */</span>
};
</pre></div></p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2c02474eb3d5e3414330381a784161c4"></a><!-- doxytag: member="im_process_pnt.h::imProcessUnArithmeticOp" ref="ga2c02474eb3d5e3414330381a784161c4" args="(const imImage *src_image, imImage *dst_image, int op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessUnArithmeticOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply an arithmetic unary operation. <br/>
 Can be done in-place, images must match size. <br/>
 Destiny image can be several types depending on source: <br/>
 </p>
<ul>
<li>byte -&gt; byte, short, ushort, int, float </li>
<li>ushort -&gt; byte, short, ushort, int, float </li>
<li>int -&gt; byte, short, ushort, int, float </li>
<li>float -&gt; float </li>
<li>complex -&gt; complex If destiny is byte, then the result is cropped to 0-255.</li>
</ul>
<div class="fragment"><pre class="fragment">im.ProcessUnArithmeticOp(src_image: imImage, dst_image: imImage, op: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessUnArithmeticOpNew(image: imImage, op: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gae4150398e7c7554a92300e607bd9f9a4"></a><!-- doxytag: member="im_process_pnt.h::imProcessArithmeticOp" ref="gae4150398e7c7554a92300e607bd9f9a4" args="(const imImage *src_image1, const imImage *src_image2, imImage *dst_image, int op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessArithmeticOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a binary arithmetic operation. <br/>
 Can be done in-place, images must match size. <br/>
 Source images must match type, destiny image can be several types depending on source: <br/>
 </p>
<ul>
<li>byte -&gt; byte, short, ushort, int, float </li>
<li>ushort -&gt; short, ushort, int, float </li>
<li>int -&gt; int, float </li>
<li>float -&gt; float </li>
<li>complex -&gt; complex One exception is that you can combine complex with float resulting complex. If destiny is byte, then the result is cropped to 0-255. Alpha channel is not included.</li>
</ul>
<div class="fragment"><pre class="fragment">im.ProcessArithmeticOp(src_image1: imImage, src_image2: imImage, dst_image: imImage, op: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessArithmeticOpNew(image1: imImage, image2: imImage, op: number) -&gt; new_image: imImage [in Lua 5] </pre></div><p> The New function will create a new image of the same type of the source images. </p>

</div>
</div>
<a class="anchor" id="ga1d1a4bd1c0f935afeb820cc2fb7c7f7b"></a><!-- doxytag: member="im_process_pnt.h::imProcessArithmeticConstOp" ref="ga1d1a4bd1c0f935afeb820cc2fb7c7f7b" args="(const imImage *src_image, float src_const, imImage *dst_image, int op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessArithmeticConstOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>src_const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Apply a binary arithmetic operation with a constant value. <br/>
 Can be done in-place, images must match size. <br/>
 Destiny image can be several types depending on source: <br/>
 </p>
<ul>
<li>byte -&gt; byte, short, ushort, int, float </li>
<li>ushort -&gt; byte, short, ushort, int, float </li>
<li>int -&gt; byte, short, ushort, int, float </li>
<li>float -&gt; float </li>
<li>complex -&gt; complex The constant value is type casted to an apropriate type before the operation. If destiny is byte, then the result is cropped to 0-255.</li>
</ul>
<div class="fragment"><pre class="fragment">im.ProcessArithmeticConstOp(src_image: imImage, src_const: number, dst_image: imImage, op: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessArithmeticConstOpNew(image: imImage, src_const: number, op: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gaa7149d9178bf72e67845a69f210b531f"></a><!-- doxytag: member="im_process_pnt.h::imProcessBlendConst" ref="gaa7149d9178bf72e67845a69f210b531f" args="(const imImage *src_image1, const imImage *src_image2, imImage *dst_image, float alpha)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessBlendConst </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>alpha</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blend two images using an alpha value = [a * alpha + b * (1 - alpha)]. <br/>
 Can be done in-place, images must match size and type. <br/>
 alpha value must be in the interval [0.0 - 1.0].</p>
<div class="fragment"><pre class="fragment">im.ProcessBlendConst(src_image1: imImage, src_image2: imImage, dst_image: imImage, alpha: number) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessBlendConstNew(image1: imImage, image2: imImage, alpha: number) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga64d21be0d738075e6df8a5f501e6a7b5"></a><!-- doxytag: member="im_process_pnt.h::imProcessBlend" ref="ga64d21be0d738075e6df8a5f501e6a7b5" args="(const imImage *src_image1, const imImage *src_image2, const imImage *alpha_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessBlend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>alpha_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Blend two images using an alpha channel = [a * alpha + b * (1 - alpha)]. <br/>
 Can be done in-place, images must match size and type. <br/>
 alpha_image must have the same data type except for complex images that must be float, and color_space must be IM_GRAY. Maximum alpha values are baed in <a class="el" href="group__color.html#gaf173e48bd6a783395a27a17a3b8c2f2a">imColorMax</a>. Minimum is always 0. </p>
<div class="fragment"><pre class="fragment">im.ProcessBlend(src_image1: imImage, src_image2: imImage, alpha_image: imImage, dst_image: imImage) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessBlendNew(image1: imImage, image2: imImage, alpha_image: imImage) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gaf25da0ee5698ee8bfde2f1c1037de60d"></a><!-- doxytag: member="im_process_pnt.h::imProcessCompose" ref="gaf25da0ee5698ee8bfde2f1c1037de60d" args="(const imImage *src_image1, const imImage *src_image2, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessCompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compose two images that have an alpha channel using the OVER operator. <br/>
 Can be done in-place, images must match size and type. <br/>
 Maximum alpha values are baed in <a class="el" href="group__color.html#gaf173e48bd6a783395a27a17a3b8c2f2a">imColorMax</a>. Minimum is always 0. </p>
<div class="fragment"><pre class="fragment">im.ProcessCompose(src_image1: imImage, src_image2: imImage, dst_image: imImage) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessComposeNew(image1: imImage, image2: imImage) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gaad8b537563985dcdb2c924d6d822d7b3"></a><!-- doxytag: member="im_process_pnt.h::imProcessSplitComplex" ref="gaad8b537563985dcdb2c924d6d822d7b3" args="(const imImage *src_image, imImage *dst_image1, imImage *dst_image2, int polar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessSplitComplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>polar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Split a complex image into two images with real and imaginary parts <br/>
 or magnitude and phase parts (polar). <br/>
 Source image must be IM_CFLOAT, destiny images must be IM_FLOAT.</p>
<div class="fragment"><pre class="fragment">im.ProcessSplitComplex(src_image: imImage, dst_image1: imImage, dst_image2: imImage, polar: boolean) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessSplitComplexNew(image: imImage, polar: boolean) -&gt; dst_image1: imImage, dst_image2: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gafc5d9030516644575df4ca8f234a5153"></a><!-- doxytag: member="im_process_pnt.h::imProcessMergeComplex" ref="gafc5d9030516644575df4ca8f234a5153" args="(const imImage *src_image1, const imImage *src_image2, imImage *dst_image, int polar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessMergeComplex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>polar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Merges two images as the real and imaginary parts of a complex image, <br/>
 or as magnitude and phase parts (polar = 1). <br/>
 Source images must be IM_FLOAT, destiny image must be IM_CFLOAT.</p>
<div class="fragment"><pre class="fragment">im.ProcessMergeComplex(src_image1: imImage, src_image2: imImage, dst_image: imImage, polar: boolean) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMergeComplexNew(image1: imImage, image2: imImage, polar: boolean) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gae96f6422f02f2573ca7f2f5ead2fd872"></a><!-- doxytag: member="im_process_pnt.h::imProcessMultipleMean" ref="gae96f6422f02f2573ca7f2f5ead2fd872" args="(const imImage **src_image_list, int src_image_count, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessMultipleMean </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> **&nbsp;</td>
          <td class="paramname"> <em>src_image_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_image_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the mean of multiple images. <br/>
 Images must match size and type.</p>
<div class="fragment"><pre class="fragment">im.ProcessMultipleMean(src_image_list: table of imImage, dst_image: imImage) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMultipleMeanNew(src_image_list: table of imImage) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga7f87abbc404ff7cb4db95e682cf92399"></a><!-- doxytag: member="im_process_pnt.h::imProcessMultipleStdDev" ref="ga7f87abbc404ff7cb4db95e682cf92399" args="(const imImage **src_image_list, int src_image_count, const imImage *mean_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessMultipleStdDev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> **&nbsp;</td>
          <td class="paramname"> <em>src_image_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>src_image_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>mean_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the standard deviation of multiple images. <br/>
 Images must match size and type. Use <a class="el" href="group__arithm.html#gae96f6422f02f2573ca7f2f5ead2fd872">imProcessMultipleMean</a> to calculate the mean_image.</p>
<div class="fragment"><pre class="fragment">im.ProcessMultipleStdDev(src_image_list: table of imImage, mean_image: imImage, dst_image: imImage) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMultipleStdDevNew(src_image_list: table of imImage, mean_image: imImage) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="ga48ce1591eb4f5ec4beeb6ac63ce68e9d"></a><!-- doxytag: member="im_process_pnt.h::imProcessAutoCovariance" ref="ga48ce1591eb4f5ec4beeb6ac63ce68e9d" args="(const imImage *src_image, const imImage *mean_image, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int imProcessAutoCovariance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>mean_image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the auto-covariance of an image with the mean of a set of images. <br/>
 Images must match size and type. Returns zero if the counter aborted. <br/>
 Destiny is IM_FLOAT. Returns zero if the counter aborted.</p>
<div class="fragment"><pre class="fragment">im.ProcessAutoCovariance(src_image: imImage, mean_image: imImage, dst_image: imImage) -&gt; counter: boolean [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessAutoCovarianceNew(src_image: imImage, mean_image: imImage) -&gt; counter: boolean, new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
<a class="anchor" id="gab1421ed016c60555c85b418535b8baa6"></a><!-- doxytag: member="im_process_pnt.h::imProcessMultiplyConj" ref="gab1421ed016c60555c85b418535b8baa6" args="(const imImage *src_image1, const imImage *src_image2, imImage *dst_image)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void imProcessMultiplyConj </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>src_image2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct__imImage.html">imImage</a> *&nbsp;</td>
          <td class="paramname"> <em>dst_image</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Multiplies the conjugate of one complex image with another complex image. <br/>
 Images must match size. Conj(img1) * img2 <br/>
 Can be done in-place.</p>
<div class="fragment"><pre class="fragment">im.ProcessMultiplyConj(src_image1: imImage, src_image2: imImage, dst_image: imImage) [in Lua 5] </pre></div> <div class="fragment"><pre class="fragment">im.ProcessMultiplyConjNew(src_image1: imImage, src_image2: imImage) -&gt; new_image: imImage [in Lua 5] </pre></div> 
</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue May 15 2012 12:06:07 for IM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
